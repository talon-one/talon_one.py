# coding: utf-8

"""
    Talon.One API

    The Talon.One API is used to manage applications and campaigns, as well as to integrate with your application. The operations in the _Integration API_ section are used to integrate with our platform, while the other operations are used to manage applications and campaigns.  ### Where is the API?  The API is available at the same hostname as these docs. For example, if you are reading this page at `https://mycompany.talon.one/docs/api/`, the URL for the [updateCustomerProfile][] operation is `https://mycompany.talon.one/v1/customer_profiles/id`  [updateCustomerProfile]: #operation--v1-customer_profiles--integrationId--put   # noqa: E501

    OpenAPI spec version: 1.0.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from talon_one.api_client import ApiClient


class ManagementApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_loyalty_points(self, program_id, integration_id, body, **kwargs):  # noqa: E501
        """Add points in a certain loyalty program for the specified customer  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_loyalty_points(program_id, integration_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str program_id: (required)
        :param str integration_id: (required)
        :param LoyaltyPoints body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_loyalty_points_with_http_info(program_id, integration_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_loyalty_points_with_http_info(program_id, integration_id, body, **kwargs)  # noqa: E501
            return data

    def add_loyalty_points_with_http_info(self, program_id, integration_id, body, **kwargs):  # noqa: E501
        """Add points in a certain loyalty program for the specified customer  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_loyalty_points_with_http_info(program_id, integration_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str program_id: (required)
        :param str integration_id: (required)
        :param LoyaltyPoints body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['program_id', 'integration_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_loyalty_points" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'program_id' is set
        if ('program_id' not in params or
                params['program_id'] is None):
            raise ValueError("Missing the required parameter `program_id` when calling `add_loyalty_points`")  # noqa: E501
        # verify the required parameter 'integration_id' is set
        if ('integration_id' not in params or
                params['integration_id'] is None):
            raise ValueError("Missing the required parameter `integration_id` when calling `add_loyalty_points`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_loyalty_points`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'program_id' in params:
            path_params['programID'] = params['program_id']  # noqa: E501
        if 'integration_id' in params:
            path_params['integrationID'] = params['integration_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/loyalty_programs/{programID}/profile/{integrationID}/add_points', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def copy_campaign_to_applications(self, application_id, campaign_id, body, **kwargs):  # noqa: E501
        """Copy the campaign into every specified application  # noqa: E501

        Copy the campaign into every specified application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_campaign_to_applications(application_id, campaign_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param int campaign_id:  (required)
        :param CampaignCopy body: (required)
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.copy_campaign_to_applications_with_http_info(application_id, campaign_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.copy_campaign_to_applications_with_http_info(application_id, campaign_id, body, **kwargs)  # noqa: E501
            return data

    def copy_campaign_to_applications_with_http_info(self, application_id, campaign_id, body, **kwargs):  # noqa: E501
        """Copy the campaign into every specified application  # noqa: E501

        Copy the campaign into every specified application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_campaign_to_applications_with_http_info(application_id, campaign_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param int campaign_id:  (required)
        :param CampaignCopy body: (required)
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'campaign_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method copy_campaign_to_applications" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `copy_campaign_to_applications`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if ('campaign_id' not in params or
                params['campaign_id'] is None):
            raise ValueError("Missing the required parameter `campaign_id` when calling `copy_campaign_to_applications`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `copy_campaign_to_applications`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501
        if 'campaign_id' in params:
            path_params['campaignId'] = params['campaign_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/copy', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2003',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_campaign(self, application_id, body, **kwargs):  # noqa: E501
        """Create a Campaign  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_campaign(application_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param NewCampaign body: (required)
        :return: Campaign
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_campaign_with_http_info(application_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_campaign_with_http_info(application_id, body, **kwargs)  # noqa: E501
            return data

    def create_campaign_with_http_info(self, application_id, body, **kwargs):  # noqa: E501
        """Create a Campaign  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_campaign_with_http_info(application_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param NewCampaign body: (required)
        :return: Campaign
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_campaign" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `create_campaign`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_campaign`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Campaign',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_coupons(self, application_id, campaign_id, body, **kwargs):  # noqa: E501
        """Create Coupons  # noqa: E501

        Create coupons according to some pattern. Up to 20.000 coupons can be created without a unique prefix. When a unique prefix is provided, up to 200.000 coupns can be created.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_coupons(application_id, campaign_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param int campaign_id:  (required)
        :param NewCoupons body: (required)
        :param str silent: If set to 'yes', response will be an empty 204, otherwise a list of the coupons generated (to to 1000).
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_coupons_with_http_info(application_id, campaign_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_coupons_with_http_info(application_id, campaign_id, body, **kwargs)  # noqa: E501
            return data

    def create_coupons_with_http_info(self, application_id, campaign_id, body, **kwargs):  # noqa: E501
        """Create Coupons  # noqa: E501

        Create coupons according to some pattern. Up to 20.000 coupons can be created without a unique prefix. When a unique prefix is provided, up to 200.000 coupns can be created.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_coupons_with_http_info(application_id, campaign_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param int campaign_id:  (required)
        :param NewCoupons body: (required)
        :param str silent: If set to 'yes', response will be an empty 204, otherwise a list of the coupons generated (to to 1000).
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'campaign_id', 'body', 'silent']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_coupons" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `create_coupons`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if ('campaign_id' not in params or
                params['campaign_id'] is None):
            raise ValueError("Missing the required parameter `campaign_id` when calling `create_coupons`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_coupons`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501
        if 'campaign_id' in params:
            path_params['campaignId'] = params['campaign_id']  # noqa: E501

        query_params = []
        if 'silent' in params:
            query_params.append(('silent', params['silent']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2001',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_password_recovery_email(self, body, **kwargs):  # noqa: E501
        """Request a password reset  # noqa: E501

        Sends an email with a password recovery link to the email of an existing account.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_password_recovery_email(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NewPasswordEmail body: (required)
        :return: NewPasswordEmail
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_password_recovery_email_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_password_recovery_email_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_password_recovery_email_with_http_info(self, body, **kwargs):  # noqa: E501
        """Request a password reset  # noqa: E501

        Sends an email with a password recovery link to the email of an existing account.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_password_recovery_email_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NewPasswordEmail body: (required)
        :return: NewPasswordEmail
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_password_recovery_email" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_password_recovery_email`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/password_recovery_emails', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NewPasswordEmail',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_ruleset(self, application_id, campaign_id, body, **kwargs):  # noqa: E501
        """Create a Ruleset  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_ruleset(application_id, campaign_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param int campaign_id:  (required)
        :param NewRuleset body: (required)
        :return: Ruleset
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_ruleset_with_http_info(application_id, campaign_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_ruleset_with_http_info(application_id, campaign_id, body, **kwargs)  # noqa: E501
            return data

    def create_ruleset_with_http_info(self, application_id, campaign_id, body, **kwargs):  # noqa: E501
        """Create a Ruleset  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_ruleset_with_http_info(application_id, campaign_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param int campaign_id:  (required)
        :param NewRuleset body: (required)
        :return: Ruleset
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'campaign_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_ruleset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `create_ruleset`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if ('campaign_id' not in params or
                params['campaign_id'] is None):
            raise ValueError("Missing the required parameter `campaign_id` when calling `create_ruleset`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_ruleset`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501
        if 'campaign_id' in params:
            path_params['campaignId'] = params['campaign_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/rulesets', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Ruleset',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_session(self, body, **kwargs):  # noqa: E501
        """Create a Session  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_session(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LoginParams body: (required)
        :return: Session
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_session_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_session_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_session_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a Session  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_session_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LoginParams body: (required)
        :return: Session
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_session" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_session`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/sessions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Session',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_campaign(self, application_id, campaign_id, **kwargs):  # noqa: E501
        """Delete a Campaign  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_campaign(application_id, campaign_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param int campaign_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_campaign_with_http_info(application_id, campaign_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_campaign_with_http_info(application_id, campaign_id, **kwargs)  # noqa: E501
            return data

    def delete_campaign_with_http_info(self, application_id, campaign_id, **kwargs):  # noqa: E501
        """Delete a Campaign  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_campaign_with_http_info(application_id, campaign_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param int campaign_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'campaign_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_campaign" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `delete_campaign`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if ('campaign_id' not in params or
                params['campaign_id'] is None):
            raise ValueError("Missing the required parameter `campaign_id` when calling `delete_campaign`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501
        if 'campaign_id' in params:
            path_params['campaignId'] = params['campaign_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_coupon(self, application_id, campaign_id, coupon_id, **kwargs):  # noqa: E501
        """Delete one Coupon  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_coupon(application_id, campaign_id, coupon_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :param int campaign_id:  (required)
        :param str coupon_id: The ID of the coupon code to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_coupon_with_http_info(application_id, campaign_id, coupon_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_coupon_with_http_info(application_id, campaign_id, coupon_id, **kwargs)  # noqa: E501
            return data

    def delete_coupon_with_http_info(self, application_id, campaign_id, coupon_id, **kwargs):  # noqa: E501
        """Delete one Coupon  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_coupon_with_http_info(application_id, campaign_id, coupon_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :param int campaign_id:  (required)
        :param str coupon_id: The ID of the coupon code to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'campaign_id', 'coupon_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_coupon" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `delete_coupon`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if ('campaign_id' not in params or
                params['campaign_id'] is None):
            raise ValueError("Missing the required parameter `campaign_id` when calling `delete_coupon`")  # noqa: E501
        # verify the required parameter 'coupon_id' is set
        if ('coupon_id' not in params or
                params['coupon_id'] is None):
            raise ValueError("Missing the required parameter `coupon_id` when calling `delete_coupon`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501
        if 'campaign_id' in params:
            path_params['campaignId'] = params['campaign_id']  # noqa: E501
        if 'coupon_id' in params:
            path_params['couponId'] = params['coupon_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons/{couponId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_coupons(self, application_id, campaign_id, **kwargs):  # noqa: E501
        """Delete Coupons  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_coupons(application_id, campaign_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :param int campaign_id:  (required)
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime starts_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime starts_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime expires_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime expires_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str batch_id: Filter results by batches of coupons
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_coupons_with_http_info(application_id, campaign_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_coupons_with_http_info(application_id, campaign_id, **kwargs)  # noqa: E501
            return data

    def delete_coupons_with_http_info(self, application_id, campaign_id, **kwargs):  # noqa: E501
        """Delete Coupons  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_coupons_with_http_info(application_id, campaign_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :param int campaign_id:  (required)
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime starts_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime starts_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime expires_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime expires_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str batch_id: Filter results by batches of coupons
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'campaign_id', 'value', 'created_before', 'created_after', 'starts_after', 'starts_before', 'expires_after', 'expires_before', 'valid', 'batch_id', 'usable', 'referral_id', 'recipient_integration_id', 'exact_match']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_coupons" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `delete_coupons`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if ('campaign_id' not in params or
                params['campaign_id'] is None):
            raise ValueError("Missing the required parameter `campaign_id` when calling `delete_coupons`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501
        if 'campaign_id' in params:
            path_params['campaignId'] = params['campaign_id']  # noqa: E501

        query_params = []
        if 'value' in params:
            query_params.append(('value', params['value']))  # noqa: E501
        if 'created_before' in params:
            query_params.append(('createdBefore', params['created_before']))  # noqa: E501
        if 'created_after' in params:
            query_params.append(('createdAfter', params['created_after']))  # noqa: E501
        if 'starts_after' in params:
            query_params.append(('startsAfter', params['starts_after']))  # noqa: E501
        if 'starts_before' in params:
            query_params.append(('startsBefore', params['starts_before']))  # noqa: E501
        if 'expires_after' in params:
            query_params.append(('expiresAfter', params['expires_after']))  # noqa: E501
        if 'expires_before' in params:
            query_params.append(('expiresBefore', params['expires_before']))  # noqa: E501
        if 'valid' in params:
            query_params.append(('valid', params['valid']))  # noqa: E501
        if 'batch_id' in params:
            query_params.append(('batchId', params['batch_id']))  # noqa: E501
        if 'usable' in params:
            query_params.append(('usable', params['usable']))  # noqa: E501
        if 'referral_id' in params:
            query_params.append(('referralId', params['referral_id']))  # noqa: E501
        if 'recipient_integration_id' in params:
            query_params.append(('recipientIntegrationId', params['recipient_integration_id']))  # noqa: E501
        if 'exact_match' in params:
            query_params.append(('exactMatch', params['exact_match']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_referral(self, application_id, campaign_id, referral_id, **kwargs):  # noqa: E501
        """Delete one Referral  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_referral(application_id, campaign_id, referral_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :param int campaign_id:  (required)
        :param str referral_id: The ID of the referral code to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_referral_with_http_info(application_id, campaign_id, referral_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_referral_with_http_info(application_id, campaign_id, referral_id, **kwargs)  # noqa: E501
            return data

    def delete_referral_with_http_info(self, application_id, campaign_id, referral_id, **kwargs):  # noqa: E501
        """Delete one Referral  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_referral_with_http_info(application_id, campaign_id, referral_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :param int campaign_id:  (required)
        :param str referral_id: The ID of the referral code to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'campaign_id', 'referral_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_referral" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `delete_referral`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if ('campaign_id' not in params or
                params['campaign_id'] is None):
            raise ValueError("Missing the required parameter `campaign_id` when calling `delete_referral`")  # noqa: E501
        # verify the required parameter 'referral_id' is set
        if ('referral_id' not in params or
                params['referral_id'] is None):
            raise ValueError("Missing the required parameter `referral_id` when calling `delete_referral`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501
        if 'campaign_id' in params:
            path_params['campaignId'] = params['campaign_id']  # noqa: E501
        if 'referral_id' in params:
            path_params['referralId'] = params['referral_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/referrals/{referralId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_ruleset(self, application_id, campaign_id, ruleset_id, **kwargs):  # noqa: E501
        """Delete a Ruleset  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ruleset(application_id, campaign_id, ruleset_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param int campaign_id:  (required)
        :param int ruleset_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_ruleset_with_http_info(application_id, campaign_id, ruleset_id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_ruleset_with_http_info(application_id, campaign_id, ruleset_id, **kwargs)  # noqa: E501
            return data

    def delete_ruleset_with_http_info(self, application_id, campaign_id, ruleset_id, **kwargs):  # noqa: E501
        """Delete a Ruleset  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ruleset_with_http_info(application_id, campaign_id, ruleset_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param int campaign_id:  (required)
        :param int ruleset_id:  (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'campaign_id', 'ruleset_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_ruleset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `delete_ruleset`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if ('campaign_id' not in params or
                params['campaign_id'] is None):
            raise ValueError("Missing the required parameter `campaign_id` when calling `delete_ruleset`")  # noqa: E501
        # verify the required parameter 'ruleset_id' is set
        if ('ruleset_id' not in params or
                params['ruleset_id'] is None):
            raise ValueError("Missing the required parameter `ruleset_id` when calling `delete_ruleset`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501
        if 'campaign_id' in params:
            path_params['campaignId'] = params['campaign_id']  # noqa: E501
        if 'ruleset_id' in params:
            path_params['rulesetId'] = params['ruleset_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/rulesets/{rulesetId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_access_logs(self, application_id, range_start, range_end, **kwargs):  # noqa: E501
        """Get access logs for application  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_logs(application_id, range_start, range_end, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :param datetime range_start: Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
        :param datetime range_end: Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
        :param str path: Only return results where the request path matches the given regular expresssion.
        :param str method: Only return results where the request method matches the given regular expresssion.
        :param str status: Filter results by HTTP status codes.
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :return: InlineResponse2009
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_access_logs_with_http_info(application_id, range_start, range_end, **kwargs)  # noqa: E501
        else:
            (data) = self.get_access_logs_with_http_info(application_id, range_start, range_end, **kwargs)  # noqa: E501
            return data

    def get_access_logs_with_http_info(self, application_id, range_start, range_end, **kwargs):  # noqa: E501
        """Get access logs for application  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_logs_with_http_info(application_id, range_start, range_end, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :param datetime range_start: Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
        :param datetime range_end: Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
        :param str path: Only return results where the request path matches the given regular expresssion.
        :param str method: Only return results where the request method matches the given regular expresssion.
        :param str status: Filter results by HTTP status codes.
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :return: InlineResponse2009
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'range_start', 'range_end', 'path', 'method', 'status', 'page_size', 'skip', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_access_logs" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `get_access_logs`")  # noqa: E501
        # verify the required parameter 'range_start' is set
        if ('range_start' not in params or
                params['range_start'] is None):
            raise ValueError("Missing the required parameter `range_start` when calling `get_access_logs`")  # noqa: E501
        # verify the required parameter 'range_end' is set
        if ('range_end' not in params or
                params['range_end'] is None):
            raise ValueError("Missing the required parameter `range_end` when calling `get_access_logs`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501
        if 'method' in params:
            query_params.append(('method', params['method']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'range_start' in params:
            query_params.append(('rangeStart', params['range_start']))  # noqa: E501
        if 'range_end' in params:
            query_params.append(('rangeEnd', params['range_end']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/access_logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2009',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_access_logs_without_total_count(self, application_id, range_start, range_end, **kwargs):  # noqa: E501
        """Get access logs for application  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_logs_without_total_count(application_id, range_start, range_end, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :param datetime range_start: Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
        :param datetime range_end: Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
        :param str path: Only return results where the request path matches the given regular expresssion.
        :param str method: Only return results where the request method matches the given regular expresssion.
        :param str status: Filter results by HTTP status codes.
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :return: InlineResponse20010
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_access_logs_without_total_count_with_http_info(application_id, range_start, range_end, **kwargs)  # noqa: E501
        else:
            (data) = self.get_access_logs_without_total_count_with_http_info(application_id, range_start, range_end, **kwargs)  # noqa: E501
            return data

    def get_access_logs_without_total_count_with_http_info(self, application_id, range_start, range_end, **kwargs):  # noqa: E501
        """Get access logs for application  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_logs_without_total_count_with_http_info(application_id, range_start, range_end, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :param datetime range_start: Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
        :param datetime range_end: Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
        :param str path: Only return results where the request path matches the given regular expresssion.
        :param str method: Only return results where the request method matches the given regular expresssion.
        :param str status: Filter results by HTTP status codes.
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :return: InlineResponse20010
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'range_start', 'range_end', 'path', 'method', 'status', 'page_size', 'skip', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_access_logs_without_total_count" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `get_access_logs_without_total_count`")  # noqa: E501
        # verify the required parameter 'range_start' is set
        if ('range_start' not in params or
                params['range_start'] is None):
            raise ValueError("Missing the required parameter `range_start` when calling `get_access_logs_without_total_count`")  # noqa: E501
        # verify the required parameter 'range_end' is set
        if ('range_end' not in params or
                params['range_end'] is None):
            raise ValueError("Missing the required parameter `range_end` when calling `get_access_logs_without_total_count`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501

        query_params = []
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501
        if 'method' in params:
            query_params.append(('method', params['method']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'range_start' in params:
            query_params.append(('rangeStart', params['range_start']))  # noqa: E501
        if 'range_end' in params:
            query_params.append(('rangeEnd', params['range_end']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/access_logs/no_total', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20010',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_account(self, account_id, **kwargs):  # noqa: E501
        """Get Account Details  # noqa: E501

        Return the details of your companies Talon.One account.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id:  (required)
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_account_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_account_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def get_account_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """Get Account Details  # noqa: E501

        Return the details of your companies Talon.One account.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id:  (required)
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `get_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['accountId'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{accountId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Account',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_account_analytics(self, account_id, **kwargs):  # noqa: E501
        """Get Account Analytics  # noqa: E501

        Return the analytics of your companies Talon.One account.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_analytics(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id:  (required)
        :return: AccountAnalytics
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_account_analytics_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_account_analytics_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def get_account_analytics_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """Get Account Analytics  # noqa: E501

        Return the analytics of your companies Talon.One account.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_analytics_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id:  (required)
        :return: AccountAnalytics
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_analytics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `get_account_analytics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['accountId'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{accountId}/analytics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccountAnalytics',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_account_limits(self, account_id, **kwargs):  # noqa: E501
        """Get Account Limits  # noqa: E501

        Returns a list of all account limits set   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_limits(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id:  (required)
        :return: AccountLimits
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_account_limits_with_http_info(account_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_account_limits_with_http_info(account_id, **kwargs)  # noqa: E501
            return data

    def get_account_limits_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """Get Account Limits  # noqa: E501

        Returns a list of all account limits set   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_limits_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id:  (required)
        :return: AccountLimits
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_limits" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `get_account_limits`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['accountId'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{accountId}/limits', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccountLimits',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_access_logs(self, range_start, range_end, **kwargs):  # noqa: E501
        """Get all access logs  # noqa: E501

        Fetches the access logs for the entire account. Sensitive requests (logins) are _always_ filtered from the logs.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_access_logs(range_start, range_end, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime range_start: Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
        :param datetime range_end: Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
        :param str path: Only return results where the request path matches the given regular expresssion.
        :param str method: Only return results where the request method matches the given regular expresssion.
        :param str status: Filter results by HTTP status codes.
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :return: InlineResponse2009
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_access_logs_with_http_info(range_start, range_end, **kwargs)  # noqa: E501
        else:
            (data) = self.get_all_access_logs_with_http_info(range_start, range_end, **kwargs)  # noqa: E501
            return data

    def get_all_access_logs_with_http_info(self, range_start, range_end, **kwargs):  # noqa: E501
        """Get all access logs  # noqa: E501

        Fetches the access logs for the entire account. Sensitive requests (logins) are _always_ filtered from the logs.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_access_logs_with_http_info(range_start, range_end, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime range_start: Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
        :param datetime range_end: Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
        :param str path: Only return results where the request path matches the given regular expresssion.
        :param str method: Only return results where the request method matches the given regular expresssion.
        :param str status: Filter results by HTTP status codes.
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :return: InlineResponse2009
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['range_start', 'range_end', 'path', 'method', 'status', 'page_size', 'skip', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_access_logs" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'range_start' is set
        if ('range_start' not in params or
                params['range_start'] is None):
            raise ValueError("Missing the required parameter `range_start` when calling `get_all_access_logs`")  # noqa: E501
        # verify the required parameter 'range_end' is set
        if ('range_end' not in params or
                params['range_end'] is None):
            raise ValueError("Missing the required parameter `range_end` when calling `get_all_access_logs`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'range_start' in params:
            query_params.append(('rangeStart', params['range_start']))  # noqa: E501
        if 'range_end' in params:
            query_params.append(('rangeEnd', params['range_end']))  # noqa: E501
        if 'path' in params:
            query_params.append(('path', params['path']))  # noqa: E501
        if 'method' in params:
            query_params.append(('method', params['method']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/access_logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2009',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_roles(self, **kwargs):  # noqa: E501
        """Get all roles.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_roles(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20028
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_all_roles_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_all_roles_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_all_roles_with_http_info(self, **kwargs):  # noqa: E501
        """Get all roles.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_roles_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse20028
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_roles" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/roles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20028',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_application(self, application_id, **kwargs):  # noqa: E501
        """Get Application  # noqa: E501

        Get the application specified by the ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :return: Application
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_application_with_http_info(application_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_application_with_http_info(application_id, **kwargs)  # noqa: E501
            return data

    def get_application_with_http_info(self, application_id, **kwargs):  # noqa: E501
        """Get Application  # noqa: E501

        Get the application specified by the ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_with_http_info(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :return: Application
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_application" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `get_application`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Application',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_application_api_health(self, application_id, **kwargs):  # noqa: E501
        """Get report of health of application API  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_api_health(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :return: ApplicationApiHealth
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_application_api_health_with_http_info(application_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_application_api_health_with_http_info(application_id, **kwargs)  # noqa: E501
            return data

    def get_application_api_health_with_http_info(self, application_id, **kwargs):  # noqa: E501
        """Get report of health of application API  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_api_health_with_http_info(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :return: ApplicationApiHealth
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_application_api_health" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `get_application_api_health`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/health_report', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApplicationApiHealth',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_application_customer(self, application_id, customer_id, **kwargs):  # noqa: E501
        """Get Application Customer  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_customer(application_id, customer_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :param int customer_id:  (required)
        :return: ApplicationCustomer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_application_customer_with_http_info(application_id, customer_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_application_customer_with_http_info(application_id, customer_id, **kwargs)  # noqa: E501
            return data

    def get_application_customer_with_http_info(self, application_id, customer_id, **kwargs):  # noqa: E501
        """Get Application Customer  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_customer_with_http_info(application_id, customer_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :param int customer_id:  (required)
        :return: ApplicationCustomer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'customer_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_application_customer" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `get_application_customer`")  # noqa: E501
        # verify the required parameter 'customer_id' is set
        if ('customer_id' not in params or
                params['customer_id'] is None):
            raise ValueError("Missing the required parameter `customer_id` when calling `get_application_customer`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501
        if 'customer_id' in params:
            path_params['customerId'] = params['customer_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/customers/{customerId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApplicationCustomer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_application_customers(self, application_id, **kwargs):  # noqa: E501
        """List Application Customers  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_customers(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :return: InlineResponse20012
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_application_customers_with_http_info(application_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_application_customers_with_http_info(application_id, **kwargs)  # noqa: E501
            return data

    def get_application_customers_with_http_info(self, application_id, **kwargs):  # noqa: E501
        """List Application Customers  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_customers_with_http_info(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :return: InlineResponse20012
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_application_customers" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `get_application_customers`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/customers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20012',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_application_customers_by_attributes(self, body, **kwargs):  # noqa: E501
        """Get a list of the customer profiles that match the given attributes  # noqa: E501

        Gets a list of all the customer profiles for the account that exactly match a set of attributes.  The match is successful if all the attributes of the request are found in a profile, even if the profile has more attributes that are not present on the request.  [Customer Profile]: http://help.talon.one/customer/en/portal/articles/2525263-data-model?b_id=14115#customer-profile   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_customers_by_attributes(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ApplicationCustomerSearch body: (required)
        :return: InlineResponse20013
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_application_customers_by_attributes_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.get_application_customers_by_attributes_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def get_application_customers_by_attributes_with_http_info(self, body, **kwargs):  # noqa: E501
        """Get a list of the customer profiles that match the given attributes  # noqa: E501

        Gets a list of all the customer profiles for the account that exactly match a set of attributes.  The match is successful if all the attributes of the request are found in a profile, even if the profile has more attributes that are not present on the request.  [Customer Profile]: http://help.talon.one/customer/en/portal/articles/2525263-data-model?b_id=14115#customer-profile   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_customers_by_attributes_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ApplicationCustomerSearch body: (required)
        :return: InlineResponse20013
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_application_customers_by_attributes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `get_application_customers_by_attributes`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['integration_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/application_customer_search', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20013',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_application_event_types(self, application_id, **kwargs):  # noqa: E501
        """List Applications Event Types  # noqa: E501

        Get all of the distinct values of the Event `type` property for events recorded in the application.  See also: [Track an event](/integration-api/reference/#trackEvent)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_event_types(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :return: InlineResponse20019
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_application_event_types_with_http_info(application_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_application_event_types_with_http_info(application_id, **kwargs)  # noqa: E501
            return data

    def get_application_event_types_with_http_info(self, application_id, **kwargs):  # noqa: E501
        """List Applications Event Types  # noqa: E501

        Get all of the distinct values of the Event `type` property for events recorded in the application.  See also: [Track an event](/integration-api/reference/#trackEvent)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_event_types_with_http_info(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :return: InlineResponse20019
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'page_size', 'skip', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_application_event_types" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `get_application_event_types`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501

        query_params = []
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/event_types', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20019',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_application_events(self, application_id, **kwargs):  # noqa: E501
        """List Applications Events  # noqa: E501

        Lists all events recorded for an application.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_events(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str type: Comma-separated list of types by which to filter events. Must be exact match(es).
        :param datetime created_before: Only return events created before this date
        :param datetime created_after: Only return events created after this date
        :param str session: Session integration ID filter for events. Must be exact match.
        :param str profile: Profile integration ID filter for events. Must be exact match.
        :param str customer_name: Customer name filter for events. Will match substrings case-insensitively.
        :param str customer_email: Customer e-mail address filter for events. Will match substrings case-insensitively.
        :param str effects_query: Effects filter for events. Will perform a full-text search on the text content of the events effects, if any.
        :param str attributes_query: Attributes filter for events. Will perform a full-text search on the text content of the events attributes, both keys and values.
        :param str rule_query: Rule name filter for events
        :param str campaign_query: Campaign name filter for events
        :return: InlineResponse20017
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_application_events_with_http_info(application_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_application_events_with_http_info(application_id, **kwargs)  # noqa: E501
            return data

    def get_application_events_with_http_info(self, application_id, **kwargs):  # noqa: E501
        """List Applications Events  # noqa: E501

        Lists all events recorded for an application.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_events_with_http_info(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str type: Comma-separated list of types by which to filter events. Must be exact match(es).
        :param datetime created_before: Only return events created before this date
        :param datetime created_after: Only return events created after this date
        :param str session: Session integration ID filter for events. Must be exact match.
        :param str profile: Profile integration ID filter for events. Must be exact match.
        :param str customer_name: Customer name filter for events. Will match substrings case-insensitively.
        :param str customer_email: Customer e-mail address filter for events. Will match substrings case-insensitively.
        :param str effects_query: Effects filter for events. Will perform a full-text search on the text content of the events effects, if any.
        :param str attributes_query: Attributes filter for events. Will perform a full-text search on the text content of the events attributes, both keys and values.
        :param str rule_query: Rule name filter for events
        :param str campaign_query: Campaign name filter for events
        :return: InlineResponse20017
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'page_size', 'skip', 'sort', 'type', 'created_before', 'created_after', 'session', 'profile', 'customer_name', 'customer_email', 'effects_query', 'attributes_query', 'rule_query', 'campaign_query']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_application_events" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `get_application_events`")  # noqa: E501

        if ('customer_name' in params and
                len(params['customer_name']) < 2):
            raise ValueError("Invalid value for parameter `customer_name` when calling `get_application_events`, length must be greater than or equal to `2`")  # noqa: E501
        if ('customer_email' in params and
                len(params['customer_email']) < 2):
            raise ValueError("Invalid value for parameter `customer_email` when calling `get_application_events`, length must be greater than or equal to `2`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501

        query_params = []
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'created_before' in params:
            query_params.append(('createdBefore', params['created_before']))  # noqa: E501
        if 'created_after' in params:
            query_params.append(('createdAfter', params['created_after']))  # noqa: E501
        if 'session' in params:
            query_params.append(('session', params['session']))  # noqa: E501
        if 'profile' in params:
            query_params.append(('profile', params['profile']))  # noqa: E501
        if 'customer_name' in params:
            query_params.append(('customerName', params['customer_name']))  # noqa: E501
        if 'customer_email' in params:
            query_params.append(('customerEmail', params['customer_email']))  # noqa: E501
        if 'effects_query' in params:
            query_params.append(('effectsQuery', params['effects_query']))  # noqa: E501
        if 'attributes_query' in params:
            query_params.append(('attributesQuery', params['attributes_query']))  # noqa: E501
        if 'rule_query' in params:
            query_params.append(('ruleQuery', params['rule_query']))  # noqa: E501
        if 'campaign_query' in params:
            query_params.append(('campaignQuery', params['campaign_query']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/events', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20017',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_application_events_without_total_count(self, application_id, **kwargs):  # noqa: E501
        """List Applications Events  # noqa: E501

        Lists all events recorded for an application. Instead of having the total number of results in the response, this endpoint only if there are more results.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_events_without_total_count(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str type: Comma-separated list of types by which to filter events. Must be exact match(es).
        :param datetime created_before: Only return events created before this date
        :param datetime created_after: Only return events created after this date
        :param str session: Session integration ID filter for events. Must be exact match.
        :param str profile: Profile integration ID filter for events. Must be exact match.
        :param str customer_name: Customer name filter for events. Will match substrings case-insensitively.
        :param str customer_email: Customer e-mail address filter for events. Will match substrings case-insensitively.
        :param str effects_query: Effects filter for events. Will perform a full-text search on the text content of the events effects, if any.
        :param str attributes_query: Attributes filter for events. Will perform a full-text search on the text content of the events attributes, both keys and values.
        :param str rule_query: Rule name filter for events
        :param str campaign_query: Campaign name filter for events
        :return: InlineResponse20018
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_application_events_without_total_count_with_http_info(application_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_application_events_without_total_count_with_http_info(application_id, **kwargs)  # noqa: E501
            return data

    def get_application_events_without_total_count_with_http_info(self, application_id, **kwargs):  # noqa: E501
        """List Applications Events  # noqa: E501

        Lists all events recorded for an application. Instead of having the total number of results in the response, this endpoint only if there are more results.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_events_without_total_count_with_http_info(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str type: Comma-separated list of types by which to filter events. Must be exact match(es).
        :param datetime created_before: Only return events created before this date
        :param datetime created_after: Only return events created after this date
        :param str session: Session integration ID filter for events. Must be exact match.
        :param str profile: Profile integration ID filter for events. Must be exact match.
        :param str customer_name: Customer name filter for events. Will match substrings case-insensitively.
        :param str customer_email: Customer e-mail address filter for events. Will match substrings case-insensitively.
        :param str effects_query: Effects filter for events. Will perform a full-text search on the text content of the events effects, if any.
        :param str attributes_query: Attributes filter for events. Will perform a full-text search on the text content of the events attributes, both keys and values.
        :param str rule_query: Rule name filter for events
        :param str campaign_query: Campaign name filter for events
        :return: InlineResponse20018
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'page_size', 'skip', 'sort', 'type', 'created_before', 'created_after', 'session', 'profile', 'customer_name', 'customer_email', 'effects_query', 'attributes_query', 'rule_query', 'campaign_query']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_application_events_without_total_count" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `get_application_events_without_total_count`")  # noqa: E501

        if ('customer_name' in params and
                len(params['customer_name']) < 2):
            raise ValueError("Invalid value for parameter `customer_name` when calling `get_application_events_without_total_count`, length must be greater than or equal to `2`")  # noqa: E501
        if ('customer_email' in params and
                len(params['customer_email']) < 2):
            raise ValueError("Invalid value for parameter `customer_email` when calling `get_application_events_without_total_count`, length must be greater than or equal to `2`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501

        query_params = []
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'type' in params:
            query_params.append(('type', params['type']))  # noqa: E501
        if 'created_before' in params:
            query_params.append(('createdBefore', params['created_before']))  # noqa: E501
        if 'created_after' in params:
            query_params.append(('createdAfter', params['created_after']))  # noqa: E501
        if 'session' in params:
            query_params.append(('session', params['session']))  # noqa: E501
        if 'profile' in params:
            query_params.append(('profile', params['profile']))  # noqa: E501
        if 'customer_name' in params:
            query_params.append(('customerName', params['customer_name']))  # noqa: E501
        if 'customer_email' in params:
            query_params.append(('customerEmail', params['customer_email']))  # noqa: E501
        if 'effects_query' in params:
            query_params.append(('effectsQuery', params['effects_query']))  # noqa: E501
        if 'attributes_query' in params:
            query_params.append(('attributesQuery', params['attributes_query']))  # noqa: E501
        if 'rule_query' in params:
            query_params.append(('ruleQuery', params['rule_query']))  # noqa: E501
        if 'campaign_query' in params:
            query_params.append(('campaignQuery', params['campaign_query']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/events/no_total', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20018',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_application_session(self, application_id, session_id, **kwargs):  # noqa: E501
        """Get Application Session  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_session(application_id, session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :param int session_id:  (required)
        :return: ApplicationSession
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_application_session_with_http_info(application_id, session_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_application_session_with_http_info(application_id, session_id, **kwargs)  # noqa: E501
            return data

    def get_application_session_with_http_info(self, application_id, session_id, **kwargs):  # noqa: E501
        """Get Application Session  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_session_with_http_info(application_id, session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :param int session_id:  (required)
        :return: ApplicationSession
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'session_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_application_session" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `get_application_session`")  # noqa: E501
        # verify the required parameter 'session_id' is set
        if ('session_id' not in params or
                params['session_id'] is None):
            raise ValueError("Missing the required parameter `session_id` when calling `get_application_session`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501
        if 'session_id' in params:
            path_params['sessionId'] = params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/sessions/{sessionId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApplicationSession',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_application_sessions(self, application_id, **kwargs):  # noqa: E501
        """List Application Sessions  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_sessions(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str profile: Profile integration ID filter for sessions. Must be exact match.
        :param str state: Filter by sessions with this state. Must be exact match.
        :param str coupon: Filter by sessions with this coupon. Must be exact match.
        :return: InlineResponse20016
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_application_sessions_with_http_info(application_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_application_sessions_with_http_info(application_id, **kwargs)  # noqa: E501
            return data

    def get_application_sessions_with_http_info(self, application_id, **kwargs):  # noqa: E501
        """List Application Sessions  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_sessions_with_http_info(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str profile: Profile integration ID filter for sessions. Must be exact match.
        :param str state: Filter by sessions with this state. Must be exact match.
        :param str coupon: Filter by sessions with this coupon. Must be exact match.
        :return: InlineResponse20016
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'page_size', 'skip', 'sort', 'profile', 'state', 'coupon']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_application_sessions" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `get_application_sessions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501

        query_params = []
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'profile' in params:
            query_params.append(('profile', params['profile']))  # noqa: E501
        if 'state' in params:
            query_params.append(('state', params['state']))  # noqa: E501
        if 'coupon' in params:
            query_params.append(('coupon', params['coupon']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/sessions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20016',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_applications(self, **kwargs):  # noqa: E501
        """List Applications  # noqa: E501

        List all application in the current account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_applications(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_applications_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_applications_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_applications_with_http_info(self, **kwargs):  # noqa: E501
        """List Applications  # noqa: E501

        List all application in the current account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_applications_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page_size', 'skip', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_applications" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2002',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_attribute(self, attribute_id, **kwargs):  # noqa: E501
        """Get a custom attribute  # noqa: E501

        Returns custom attribute for the account by its id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_attribute(attribute_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int attribute_id: (required)
        :return: Attribute
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_attribute_with_http_info(attribute_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_attribute_with_http_info(attribute_id, **kwargs)  # noqa: E501
            return data

    def get_attribute_with_http_info(self, attribute_id, **kwargs):  # noqa: E501
        """Get a custom attribute  # noqa: E501

        Returns custom attribute for the account by its id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_attribute_with_http_info(attribute_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int attribute_id: (required)
        :return: Attribute
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['attribute_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_attribute" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'attribute_id' is set
        if ('attribute_id' not in params or
                params['attribute_id'] is None):
            raise ValueError("Missing the required parameter `attribute_id` when calling `get_attribute`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'attribute_id' in params:
            path_params['attributeId'] = params['attribute_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/attributes/{attributeId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Attribute',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_campaign(self, application_id, campaign_id, **kwargs):  # noqa: E501
        """Get a Campaign  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_campaign(application_id, campaign_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param int campaign_id:  (required)
        :return: Campaign
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_campaign_with_http_info(application_id, campaign_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_campaign_with_http_info(application_id, campaign_id, **kwargs)  # noqa: E501
            return data

    def get_campaign_with_http_info(self, application_id, campaign_id, **kwargs):  # noqa: E501
        """Get a Campaign  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_campaign_with_http_info(application_id, campaign_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param int campaign_id:  (required)
        :return: Campaign
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'campaign_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_campaign" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `get_campaign`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if ('campaign_id' not in params or
                params['campaign_id'] is None):
            raise ValueError("Missing the required parameter `campaign_id` when calling `get_campaign`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501
        if 'campaign_id' in params:
            path_params['campaignId'] = params['campaign_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Campaign',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_campaign_analytics(self, application_id, campaign_id, range_start, range_end, **kwargs):  # noqa: E501
        """Get analytics of campaigns  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_campaign_analytics(application_id, campaign_id, range_start, range_end, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: The identifier for the application (required)
        :param int campaign_id:  (required)
        :param datetime range_start: Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
        :param datetime range_end: Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
        :param str granularity: The time interval between the results in the returned time-series.
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_campaign_analytics_with_http_info(application_id, campaign_id, range_start, range_end, **kwargs)  # noqa: E501
        else:
            (data) = self.get_campaign_analytics_with_http_info(application_id, campaign_id, range_start, range_end, **kwargs)  # noqa: E501
            return data

    def get_campaign_analytics_with_http_info(self, application_id, campaign_id, range_start, range_end, **kwargs):  # noqa: E501
        """Get analytics of campaigns  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_campaign_analytics_with_http_info(application_id, campaign_id, range_start, range_end, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: The identifier for the application (required)
        :param int campaign_id:  (required)
        :param datetime range_start: Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
        :param datetime range_end: Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
        :param str granularity: The time interval between the results in the returned time-series.
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'campaign_id', 'range_start', 'range_end', 'granularity']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_campaign_analytics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `get_campaign_analytics`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if ('campaign_id' not in params or
                params['campaign_id'] is None):
            raise ValueError("Missing the required parameter `campaign_id` when calling `get_campaign_analytics`")  # noqa: E501
        # verify the required parameter 'range_start' is set
        if ('range_start' not in params or
                params['range_start'] is None):
            raise ValueError("Missing the required parameter `range_start` when calling `get_campaign_analytics`")  # noqa: E501
        # verify the required parameter 'range_end' is set
        if ('range_end' not in params or
                params['range_end'] is None):
            raise ValueError("Missing the required parameter `range_end` when calling `get_campaign_analytics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501
        if 'campaign_id' in params:
            path_params['campaignId'] = params['campaign_id']  # noqa: E501

        query_params = []
        if 'range_start' in params:
            query_params.append(('rangeStart', params['range_start']))  # noqa: E501
        if 'range_end' in params:
            query_params.append(('rangeEnd', params['range_end']))  # noqa: E501
        if 'granularity' in params:
            query_params.append(('granularity', params['granularity']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/analytics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_campaign_by_attributes(self, application_id, body, **kwargs):  # noqa: E501
        """Get a list of all campaigns that match the given attributes  # noqa: E501

        Gets a list of all the campaigns that exactly match a set of attributes.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_campaign_by_attributes(application_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param CampaignSearch body: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str campaign_state: Filter results by the state of the campaign.
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_campaign_by_attributes_with_http_info(application_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.get_campaign_by_attributes_with_http_info(application_id, body, **kwargs)  # noqa: E501
            return data

    def get_campaign_by_attributes_with_http_info(self, application_id, body, **kwargs):  # noqa: E501
        """Get a list of all campaigns that match the given attributes  # noqa: E501

        Gets a list of all the campaigns that exactly match a set of attributes.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_campaign_by_attributes_with_http_info(application_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param CampaignSearch body: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str campaign_state: Filter results by the state of the campaign.
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'body', 'page_size', 'skip', 'sort', 'campaign_state']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_campaign_by_attributes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `get_campaign_by_attributes`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `get_campaign_by_attributes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501

        query_params = []
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'campaign_state' in params:
            query_params.append(('campaignState', params['campaign_state']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns_search', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2003',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_campaign_set(self, application_id, **kwargs):  # noqa: E501
        """List CampaignSet  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_campaign_set(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :return: CampaignSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_campaign_set_with_http_info(application_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_campaign_set_with_http_info(application_id, **kwargs)  # noqa: E501
            return data

    def get_campaign_set_with_http_info(self, application_id, **kwargs):  # noqa: E501
        """List CampaignSet  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_campaign_set_with_http_info(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :return: CampaignSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_campaign_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `get_campaign_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaign_set', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CampaignSet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_campaigns(self, application_id, **kwargs):  # noqa: E501
        """List your Campaigns  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_campaigns(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str campaign_state: Filter results by the state of the campaign.
        :param str name: Filter results performing case-insensitive matching against the name of the campaign.
        :param str tags: Filter results performing case-insensitive matching against the tags of the campaign. When used in conjunction with the \"name\" query parameter, a logical OR will be performed to search both tags and name for the provided values 
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the campaign creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the campaign creation timestamp.
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_campaigns_with_http_info(application_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_campaigns_with_http_info(application_id, **kwargs)  # noqa: E501
            return data

    def get_campaigns_with_http_info(self, application_id, **kwargs):  # noqa: E501
        """List your Campaigns  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_campaigns_with_http_info(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str campaign_state: Filter results by the state of the campaign.
        :param str name: Filter results performing case-insensitive matching against the name of the campaign.
        :param str tags: Filter results performing case-insensitive matching against the tags of the campaign. When used in conjunction with the \"name\" query parameter, a logical OR will be performed to search both tags and name for the provided values 
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the campaign creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the campaign creation timestamp.
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'page_size', 'skip', 'sort', 'campaign_state', 'name', 'tags', 'created_before', 'created_after']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_campaigns" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `get_campaigns`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501

        query_params = []
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'campaign_state' in params:
            query_params.append(('campaignState', params['campaign_state']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'tags' in params:
            query_params.append(('tags', params['tags']))  # noqa: E501
        if 'created_before' in params:
            query_params.append(('createdBefore', params['created_before']))  # noqa: E501
        if 'created_after' in params:
            query_params.append(('createdAfter', params['created_after']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2003',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_changes(self, **kwargs):  # noqa: E501
        """Get audit log for an account  # noqa: E501

        Get list of changes caused by API calls for an account. Only accessible for admins.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_changes(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :return: InlineResponse20025
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_changes_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_changes_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_changes_with_http_info(self, **kwargs):  # noqa: E501
        """Get audit log for an account  # noqa: E501

        Get list of changes caused by API calls for an account. Only accessible for admins.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_changes_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :return: InlineResponse20025
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page_size', 'skip', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_changes" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/changes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20025',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_coupons(self, application_id, campaign_id, **kwargs):  # noqa: E501
        """List Coupons  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_coupons(application_id, campaign_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param int campaign_id:  (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime starts_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime starts_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime expires_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime expires_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str batch_id: Filter results by batches of coupons
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_coupons_with_http_info(application_id, campaign_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_coupons_with_http_info(application_id, campaign_id, **kwargs)  # noqa: E501
            return data

    def get_coupons_with_http_info(self, application_id, campaign_id, **kwargs):  # noqa: E501
        """List Coupons  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_coupons_with_http_info(application_id, campaign_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param int campaign_id:  (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime starts_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime starts_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime expires_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime expires_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str batch_id: Filter results by batches of coupons
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'campaign_id', 'page_size', 'skip', 'sort', 'value', 'created_before', 'created_after', 'starts_after', 'starts_before', 'expires_after', 'expires_before', 'valid', 'batch_id', 'usable', 'referral_id', 'recipient_integration_id', 'exact_match']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_coupons" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `get_coupons`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if ('campaign_id' not in params or
                params['campaign_id'] is None):
            raise ValueError("Missing the required parameter `campaign_id` when calling `get_coupons`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501
        if 'campaign_id' in params:
            path_params['campaignId'] = params['campaign_id']  # noqa: E501

        query_params = []
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'value' in params:
            query_params.append(('value', params['value']))  # noqa: E501
        if 'created_before' in params:
            query_params.append(('createdBefore', params['created_before']))  # noqa: E501
        if 'created_after' in params:
            query_params.append(('createdAfter', params['created_after']))  # noqa: E501
        if 'starts_after' in params:
            query_params.append(('startsAfter', params['starts_after']))  # noqa: E501
        if 'starts_before' in params:
            query_params.append(('startsBefore', params['starts_before']))  # noqa: E501
        if 'expires_after' in params:
            query_params.append(('expiresAfter', params['expires_after']))  # noqa: E501
        if 'expires_before' in params:
            query_params.append(('expiresBefore', params['expires_before']))  # noqa: E501
        if 'valid' in params:
            query_params.append(('valid', params['valid']))  # noqa: E501
        if 'batch_id' in params:
            query_params.append(('batchId', params['batch_id']))  # noqa: E501
        if 'usable' in params:
            query_params.append(('usable', params['usable']))  # noqa: E501
        if 'referral_id' in params:
            query_params.append(('referralId', params['referral_id']))  # noqa: E501
        if 'recipient_integration_id' in params:
            query_params.append(('recipientIntegrationId', params['recipient_integration_id']))  # noqa: E501
        if 'exact_match' in params:
            query_params.append(('exactMatch', params['exact_match']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2001',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_coupons_by_attributes(self, application_id, campaign_id, body, **kwargs):  # noqa: E501
        """Get a list of the coupons that match the given attributes  # noqa: E501

        Gets a list of all the coupons that exactly match a set of attributes.  The match is successful if all the attributes of the request are found in a coupon, even if the coupon has more attributes that are not present on the request.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_coupons_by_attributes(application_id, campaign_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param int campaign_id:  (required)
        :param CouponSearch body: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :param str batch_id: Filter results by batches of coupons
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_coupons_by_attributes_with_http_info(application_id, campaign_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.get_coupons_by_attributes_with_http_info(application_id, campaign_id, body, **kwargs)  # noqa: E501
            return data

    def get_coupons_by_attributes_with_http_info(self, application_id, campaign_id, body, **kwargs):  # noqa: E501
        """Get a list of the coupons that match the given attributes  # noqa: E501

        Gets a list of all the coupons that exactly match a set of attributes.  The match is successful if all the attributes of the request are found in a coupon, even if the coupon has more attributes that are not present on the request.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_coupons_by_attributes_with_http_info(application_id, campaign_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param int campaign_id:  (required)
        :param CouponSearch body: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :param str batch_id: Filter results by batches of coupons
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'campaign_id', 'body', 'page_size', 'skip', 'sort', 'value', 'created_before', 'created_after', 'valid', 'usable', 'referral_id', 'recipient_integration_id', 'exact_match', 'batch_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_coupons_by_attributes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `get_coupons_by_attributes`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if ('campaign_id' not in params or
                params['campaign_id'] is None):
            raise ValueError("Missing the required parameter `campaign_id` when calling `get_coupons_by_attributes`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `get_coupons_by_attributes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501
        if 'campaign_id' in params:
            path_params['campaignId'] = params['campaign_id']  # noqa: E501

        query_params = []
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'value' in params:
            query_params.append(('value', params['value']))  # noqa: E501
        if 'created_before' in params:
            query_params.append(('createdBefore', params['created_before']))  # noqa: E501
        if 'created_after' in params:
            query_params.append(('createdAfter', params['created_after']))  # noqa: E501
        if 'valid' in params:
            query_params.append(('valid', params['valid']))  # noqa: E501
        if 'usable' in params:
            query_params.append(('usable', params['usable']))  # noqa: E501
        if 'referral_id' in params:
            query_params.append(('referralId', params['referral_id']))  # noqa: E501
        if 'recipient_integration_id' in params:
            query_params.append(('recipientIntegrationId', params['recipient_integration_id']))  # noqa: E501
        if 'exact_match' in params:
            query_params.append(('exactMatch', params['exact_match']))  # noqa: E501
        if 'batch_id' in params:
            query_params.append(('batchId', params['batch_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons_search', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2001',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_coupons_by_attributes_application_wide(self, application_id, body, **kwargs):  # noqa: E501
        """Get a list of the coupons that match the given attributes in all active campaigns of an application  # noqa: E501

        Gets a list of all the coupons with attributes matching the query criteria Application wide   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_coupons_by_attributes_application_wide(application_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param CouponSearch body: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param str batch_id: Filter results by batches of coupons
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :param str campaign_state: Filter results by the state of the campaign.
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_coupons_by_attributes_application_wide_with_http_info(application_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.get_coupons_by_attributes_application_wide_with_http_info(application_id, body, **kwargs)  # noqa: E501
            return data

    def get_coupons_by_attributes_application_wide_with_http_info(self, application_id, body, **kwargs):  # noqa: E501
        """Get a list of the coupons that match the given attributes in all active campaigns of an application  # noqa: E501

        Gets a list of all the coupons with attributes matching the query criteria Application wide   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_coupons_by_attributes_application_wide_with_http_info(application_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param CouponSearch body: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param str batch_id: Filter results by batches of coupons
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :param str campaign_state: Filter results by the state of the campaign.
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'body', 'page_size', 'skip', 'sort', 'value', 'created_before', 'created_after', 'valid', 'usable', 'referral_id', 'recipient_integration_id', 'batch_id', 'exact_match', 'campaign_state']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_coupons_by_attributes_application_wide" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `get_coupons_by_attributes_application_wide`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `get_coupons_by_attributes_application_wide`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501

        query_params = []
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'value' in params:
            query_params.append(('value', params['value']))  # noqa: E501
        if 'created_before' in params:
            query_params.append(('createdBefore', params['created_before']))  # noqa: E501
        if 'created_after' in params:
            query_params.append(('createdAfter', params['created_after']))  # noqa: E501
        if 'valid' in params:
            query_params.append(('valid', params['valid']))  # noqa: E501
        if 'usable' in params:
            query_params.append(('usable', params['usable']))  # noqa: E501
        if 'referral_id' in params:
            query_params.append(('referralId', params['referral_id']))  # noqa: E501
        if 'recipient_integration_id' in params:
            query_params.append(('recipientIntegrationId', params['recipient_integration_id']))  # noqa: E501
        if 'batch_id' in params:
            query_params.append(('batchId', params['batch_id']))  # noqa: E501
        if 'exact_match' in params:
            query_params.append(('exactMatch', params['exact_match']))  # noqa: E501
        if 'campaign_state' in params:
            query_params.append(('campaignState', params['campaign_state']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/coupons_search', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2001',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_coupons_without_total_count(self, application_id, campaign_id, **kwargs):  # noqa: E501
        """List Coupons  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_coupons_without_total_count(application_id, campaign_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param int campaign_id:  (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param str batch_id: Filter results by batches of coupons
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_coupons_without_total_count_with_http_info(application_id, campaign_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_coupons_without_total_count_with_http_info(application_id, campaign_id, **kwargs)  # noqa: E501
            return data

    def get_coupons_without_total_count_with_http_info(self, application_id, campaign_id, **kwargs):  # noqa: E501
        """List Coupons  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_coupons_without_total_count_with_http_info(application_id, campaign_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param int campaign_id:  (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param str batch_id: Filter results by batches of coupons
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'campaign_id', 'page_size', 'skip', 'sort', 'value', 'created_before', 'created_after', 'valid', 'usable', 'referral_id', 'recipient_integration_id', 'batch_id', 'exact_match']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_coupons_without_total_count" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `get_coupons_without_total_count`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if ('campaign_id' not in params or
                params['campaign_id'] is None):
            raise ValueError("Missing the required parameter `campaign_id` when calling `get_coupons_without_total_count`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501
        if 'campaign_id' in params:
            path_params['campaignId'] = params['campaign_id']  # noqa: E501

        query_params = []
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'value' in params:
            query_params.append(('value', params['value']))  # noqa: E501
        if 'created_before' in params:
            query_params.append(('createdBefore', params['created_before']))  # noqa: E501
        if 'created_after' in params:
            query_params.append(('createdAfter', params['created_after']))  # noqa: E501
        if 'valid' in params:
            query_params.append(('valid', params['valid']))  # noqa: E501
        if 'usable' in params:
            query_params.append(('usable', params['usable']))  # noqa: E501
        if 'referral_id' in params:
            query_params.append(('referralId', params['referral_id']))  # noqa: E501
        if 'recipient_integration_id' in params:
            query_params.append(('recipientIntegrationId', params['recipient_integration_id']))  # noqa: E501
        if 'batch_id' in params:
            query_params.append(('batchId', params['batch_id']))  # noqa: E501
        if 'exact_match' in params:
            query_params.append(('exactMatch', params['exact_match']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons/no_total', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2005',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_customer_activity_report(self, range_start, range_end, application_id, customer_id, **kwargs):  # noqa: E501
        """Get Activity Report for Single Customer  # noqa: E501

        Fetch summary report for single application customer based on a time range  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customer_activity_report(range_start, range_end, application_id, customer_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime range_start: Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
        :param datetime range_end: Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
        :param int application_id:  (required)
        :param int customer_id:  (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :return: CustomerActivityReport
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_customer_activity_report_with_http_info(range_start, range_end, application_id, customer_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_customer_activity_report_with_http_info(range_start, range_end, application_id, customer_id, **kwargs)  # noqa: E501
            return data

    def get_customer_activity_report_with_http_info(self, range_start, range_end, application_id, customer_id, **kwargs):  # noqa: E501
        """Get Activity Report for Single Customer  # noqa: E501

        Fetch summary report for single application customer based on a time range  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customer_activity_report_with_http_info(range_start, range_end, application_id, customer_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime range_start: Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
        :param datetime range_end: Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
        :param int application_id:  (required)
        :param int customer_id:  (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :return: CustomerActivityReport
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['range_start', 'range_end', 'application_id', 'customer_id', 'page_size', 'skip']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_customer_activity_report" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'range_start' is set
        if ('range_start' not in params or
                params['range_start'] is None):
            raise ValueError("Missing the required parameter `range_start` when calling `get_customer_activity_report`")  # noqa: E501
        # verify the required parameter 'range_end' is set
        if ('range_end' not in params or
                params['range_end'] is None):
            raise ValueError("Missing the required parameter `range_end` when calling `get_customer_activity_report`")  # noqa: E501
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `get_customer_activity_report`")  # noqa: E501
        # verify the required parameter 'customer_id' is set
        if ('customer_id' not in params or
                params['customer_id'] is None):
            raise ValueError("Missing the required parameter `customer_id` when calling `get_customer_activity_report`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501
        if 'customer_id' in params:
            path_params['customerId'] = params['customer_id']  # noqa: E501

        query_params = []
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'range_start' in params:
            query_params.append(('rangeStart', params['range_start']))  # noqa: E501
        if 'range_end' in params:
            query_params.append(('rangeEnd', params['range_end']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/customer_activity_reports/{customerId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CustomerActivityReport',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_customer_activity_reports(self, range_start, range_end, application_id, **kwargs):  # noqa: E501
        """Get Activity Reports for Application Customers  # noqa: E501

        Fetch summary reports for all application customers based on a time range  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customer_activity_reports(range_start, range_end, application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime range_start: Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
        :param datetime range_end: Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
        :param int application_id:  (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str name: Only return reports matching the customer name
        :param str integration_id: Only return reports matching the integrationId
        :param str campaign_name: Only return reports matching the campaignName
        :param str advocate_name: Only return reports matching the current customer referrer name
        :return: InlineResponse20014
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_customer_activity_reports_with_http_info(range_start, range_end, application_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_customer_activity_reports_with_http_info(range_start, range_end, application_id, **kwargs)  # noqa: E501
            return data

    def get_customer_activity_reports_with_http_info(self, range_start, range_end, application_id, **kwargs):  # noqa: E501
        """Get Activity Reports for Application Customers  # noqa: E501

        Fetch summary reports for all application customers based on a time range  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customer_activity_reports_with_http_info(range_start, range_end, application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime range_start: Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
        :param datetime range_end: Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
        :param int application_id:  (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str name: Only return reports matching the customer name
        :param str integration_id: Only return reports matching the integrationId
        :param str campaign_name: Only return reports matching the campaignName
        :param str advocate_name: Only return reports matching the current customer referrer name
        :return: InlineResponse20014
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['range_start', 'range_end', 'application_id', 'page_size', 'skip', 'sort', 'name', 'integration_id', 'campaign_name', 'advocate_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_customer_activity_reports" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'range_start' is set
        if ('range_start' not in params or
                params['range_start'] is None):
            raise ValueError("Missing the required parameter `range_start` when calling `get_customer_activity_reports`")  # noqa: E501
        # verify the required parameter 'range_end' is set
        if ('range_end' not in params or
                params['range_end'] is None):
            raise ValueError("Missing the required parameter `range_end` when calling `get_customer_activity_reports`")  # noqa: E501
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `get_customer_activity_reports`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501

        query_params = []
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'range_start' in params:
            query_params.append(('rangeStart', params['range_start']))  # noqa: E501
        if 'range_end' in params:
            query_params.append(('rangeEnd', params['range_end']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'integration_id' in params:
            query_params.append(('integrationId', params['integration_id']))  # noqa: E501
        if 'campaign_name' in params:
            query_params.append(('campaignName', params['campaign_name']))  # noqa: E501
        if 'advocate_name' in params:
            query_params.append(('advocateName', params['advocate_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/customer_activity_reports', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20014',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_customer_activity_reports_without_total_count(self, range_start, range_end, application_id, **kwargs):  # noqa: E501
        """Get Activity Reports for Application Customers  # noqa: E501

        Fetch summary reports for all application customers based on a time range. Instead of having the total number of results in the response, this endpoint only if there are more results.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customer_activity_reports_without_total_count(range_start, range_end, application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime range_start: Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
        :param datetime range_end: Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
        :param int application_id:  (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str name: Only return reports matching the customer name
        :param str integration_id: Only return reports matching the integrationId
        :param str campaign_name: Only return reports matching the campaignName
        :param str advocate_name: Only return reports matching the current customer referrer name
        :return: InlineResponse20015
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_customer_activity_reports_without_total_count_with_http_info(range_start, range_end, application_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_customer_activity_reports_without_total_count_with_http_info(range_start, range_end, application_id, **kwargs)  # noqa: E501
            return data

    def get_customer_activity_reports_without_total_count_with_http_info(self, range_start, range_end, application_id, **kwargs):  # noqa: E501
        """Get Activity Reports for Application Customers  # noqa: E501

        Fetch summary reports for all application customers based on a time range. Instead of having the total number of results in the response, this endpoint only if there are more results.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customer_activity_reports_without_total_count_with_http_info(range_start, range_end, application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param datetime range_start: Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
        :param datetime range_end: Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
        :param int application_id:  (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str name: Only return reports matching the customer name
        :param str integration_id: Only return reports matching the integrationId
        :param str campaign_name: Only return reports matching the campaignName
        :param str advocate_name: Only return reports matching the current customer referrer name
        :return: InlineResponse20015
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['range_start', 'range_end', 'application_id', 'page_size', 'skip', 'sort', 'name', 'integration_id', 'campaign_name', 'advocate_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_customer_activity_reports_without_total_count" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'range_start' is set
        if ('range_start' not in params or
                params['range_start'] is None):
            raise ValueError("Missing the required parameter `range_start` when calling `get_customer_activity_reports_without_total_count`")  # noqa: E501
        # verify the required parameter 'range_end' is set
        if ('range_end' not in params or
                params['range_end'] is None):
            raise ValueError("Missing the required parameter `range_end` when calling `get_customer_activity_reports_without_total_count`")  # noqa: E501
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `get_customer_activity_reports_without_total_count`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501

        query_params = []
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'range_start' in params:
            query_params.append(('rangeStart', params['range_start']))  # noqa: E501
        if 'range_end' in params:
            query_params.append(('rangeEnd', params['range_end']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'integration_id' in params:
            query_params.append(('integrationId', params['integration_id']))  # noqa: E501
        if 'campaign_name' in params:
            query_params.append(('campaignName', params['campaign_name']))  # noqa: E501
        if 'advocate_name' in params:
            query_params.append(('advocateName', params['advocate_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/customer_activity_reports/no_total', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20015',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_customer_analytics(self, application_id, customer_id, **kwargs):  # noqa: E501
        """Get Analytics Report for a Customer  # noqa: E501

        Fetch analytics for single application customer  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customer_analytics(application_id, customer_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :param int customer_id:  (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :return: CustomerAnalytics
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_customer_analytics_with_http_info(application_id, customer_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_customer_analytics_with_http_info(application_id, customer_id, **kwargs)  # noqa: E501
            return data

    def get_customer_analytics_with_http_info(self, application_id, customer_id, **kwargs):  # noqa: E501
        """Get Analytics Report for a Customer  # noqa: E501

        Fetch analytics for single application customer  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customer_analytics_with_http_info(application_id, customer_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :param int customer_id:  (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :return: CustomerAnalytics
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'customer_id', 'page_size', 'skip', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_customer_analytics" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `get_customer_analytics`")  # noqa: E501
        # verify the required parameter 'customer_id' is set
        if ('customer_id' not in params or
                params['customer_id'] is None):
            raise ValueError("Missing the required parameter `customer_id` when calling `get_customer_analytics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501
        if 'customer_id' in params:
            path_params['customerId'] = params['customer_id']  # noqa: E501

        query_params = []
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/customers/{customerId}/analytics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CustomerAnalytics',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_customer_profile(self, application_id, customer_id, **kwargs):  # noqa: E501
        """Get Customer Profile  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customer_profile(application_id, customer_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :param int customer_id:  (required)
        :return: ApplicationCustomer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_customer_profile_with_http_info(application_id, customer_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_customer_profile_with_http_info(application_id, customer_id, **kwargs)  # noqa: E501
            return data

    def get_customer_profile_with_http_info(self, application_id, customer_id, **kwargs):  # noqa: E501
        """Get Customer Profile  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customer_profile_with_http_info(application_id, customer_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :param int customer_id:  (required)
        :return: ApplicationCustomer
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'customer_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_customer_profile" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `get_customer_profile`")  # noqa: E501
        # verify the required parameter 'customer_id' is set
        if ('customer_id' not in params or
                params['customer_id'] is None):
            raise ValueError("Missing the required parameter `customer_id` when calling `get_customer_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501
        if 'customer_id' in params:
            path_params['customerId'] = params['customer_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/customers/{customerId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApplicationCustomer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_customer_profiles(self, **kwargs):  # noqa: E501
        """List Customer Profiles  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customer_profiles(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :return: InlineResponse20013
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_customer_profiles_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_customer_profiles_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_customer_profiles_with_http_info(self, **kwargs):  # noqa: E501
        """List Customer Profiles  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customer_profiles_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :return: InlineResponse20013
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page_size', 'skip']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_customer_profiles" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/customers/no_total', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20013',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_customers_by_attributes(self, body, **kwargs):  # noqa: E501
        """Get a list of the customer profiles that match the given attributes  # noqa: E501

        Gets a list of all the customer profiles for the account that exactly match a set of attributes.  The match is successful if all the attributes of the request are found in a profile, even if the profile has more attributes that are not present on the request.  [Customer Profile]: http://help.talon.one/customer/en/portal/articles/2525263-data-model?b_id=14115#customer-profile   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customers_by_attributes(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ApplicationCustomerSearch body: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :return: InlineResponse20013
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_customers_by_attributes_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.get_customers_by_attributes_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def get_customers_by_attributes_with_http_info(self, body, **kwargs):  # noqa: E501
        """Get a list of the customer profiles that match the given attributes  # noqa: E501

        Gets a list of all the customer profiles for the account that exactly match a set of attributes.  The match is successful if all the attributes of the request are found in a profile, even if the profile has more attributes that are not present on the request.  [Customer Profile]: http://help.talon.one/customer/en/portal/articles/2525263-data-model?b_id=14115#customer-profile   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customers_by_attributes_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param ApplicationCustomerSearch body: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :return: InlineResponse20013
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'page_size', 'skip']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_customers_by_attributes" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `get_customers_by_attributes`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/customer_search/no_total', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20013',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_event_types(self, **kwargs):  # noqa: E501
        """List Event Types  # noqa: E501

        Fetch all event type definitions for your account. Each event type can be   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_event_types(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str application_ids: Filter by one or more application ids separated by comma
        :param str name: Filter results to event types with the given name. This parameter implies `includeOldVersions`.
        :param bool include_old_versions: Include all versions of every event type.
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :return: InlineResponse20023
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_event_types_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_event_types_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_event_types_with_http_info(self, **kwargs):  # noqa: E501
        """List Event Types  # noqa: E501

        Fetch all event type definitions for your account. Each event type can be   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_event_types_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str application_ids: Filter by one or more application ids separated by comma
        :param str name: Filter results to event types with the given name. This parameter implies `includeOldVersions`.
        :param bool include_old_versions: Include all versions of every event type.
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :return: InlineResponse20023
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_ids', 'name', 'include_old_versions', 'page_size', 'skip', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_event_types" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'application_ids' in params:
            query_params.append(('applicationIds', params['application_ids']))  # noqa: E501
        if 'name' in params:
            query_params.append(('name', params['name']))  # noqa: E501
        if 'include_old_versions' in params:
            query_params.append(('includeOldVersions', params['include_old_versions']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/event_types', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20023',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_exports(self, **kwargs):  # noqa: E501
        """Get Exports  # noqa: E501

        Get a list of all past exports   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_exports(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param int application_id:
        :param int campaign_id:
        :param str entity: The name of the entity type that was exported.
        :return: InlineResponse20026
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_exports_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_exports_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_exports_with_http_info(self, **kwargs):  # noqa: E501
        """Get Exports  # noqa: E501

        Get a list of all past exports   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_exports_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param int application_id:
        :param int campaign_id:
        :param str entity: The name of the entity type that was exported.
        :return: InlineResponse20026
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page_size', 'skip', 'application_id', 'campaign_id', 'entity']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_exports" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'application_id' in params:
            query_params.append(('applicationId', params['application_id']))  # noqa: E501
        if 'campaign_id' in params:
            query_params.append(('campaignId', params['campaign_id']))  # noqa: E501
        if 'entity' in params:
            query_params.append(('entity', params['entity']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/exports', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20026',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_imports(self, **kwargs):  # noqa: E501
        """Get Imports  # noqa: E501

        Get a list of all past imports   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_imports(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :return: InlineResponse20027
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_imports_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_imports_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_imports_with_http_info(self, **kwargs):  # noqa: E501
        """Get Imports  # noqa: E501

        Get a list of all past imports   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_imports_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :return: InlineResponse20027
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page_size', 'skip']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_imports" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/imports', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20027',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_loyalty_points(self, program_id, integration_id, **kwargs):  # noqa: E501
        """get the Loyalty Ledger for this integrationID  # noqa: E501

        Get the Loyalty Ledger for this profile integration ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_loyalty_points(program_id, integration_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str program_id: The identifier for the application, must be unique within the account. (required)
        :param str integration_id: The identifier for the application, must be unique within the account. (required)
        :return: LoyaltyLedger
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_loyalty_points_with_http_info(program_id, integration_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_loyalty_points_with_http_info(program_id, integration_id, **kwargs)  # noqa: E501
            return data

    def get_loyalty_points_with_http_info(self, program_id, integration_id, **kwargs):  # noqa: E501
        """get the Loyalty Ledger for this integrationID  # noqa: E501

        Get the Loyalty Ledger for this profile integration ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_loyalty_points_with_http_info(program_id, integration_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str program_id: The identifier for the application, must be unique within the account. (required)
        :param str integration_id: The identifier for the application, must be unique within the account. (required)
        :return: LoyaltyLedger
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['program_id', 'integration_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_loyalty_points" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'program_id' is set
        if ('program_id' not in params or
                params['program_id'] is None):
            raise ValueError("Missing the required parameter `program_id` when calling `get_loyalty_points`")  # noqa: E501
        # verify the required parameter 'integration_id' is set
        if ('integration_id' not in params or
                params['integration_id'] is None):
            raise ValueError("Missing the required parameter `integration_id` when calling `get_loyalty_points`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'program_id' in params:
            path_params['programID'] = params['program_id']  # noqa: E501
        if 'integration_id' in params:
            path_params['integrationID'] = params['integration_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/loyalty_programs/{programID}/profile/{integrationID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LoyaltyLedger',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_loyalty_program(self, program_id, **kwargs):  # noqa: E501
        """Get a loyalty program  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_loyalty_program(program_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str program_id: (required)
        :return: LoyaltyProgram
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_loyalty_program_with_http_info(program_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_loyalty_program_with_http_info(program_id, **kwargs)  # noqa: E501
            return data

    def get_loyalty_program_with_http_info(self, program_id, **kwargs):  # noqa: E501
        """Get a loyalty program  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_loyalty_program_with_http_info(program_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str program_id: (required)
        :return: LoyaltyProgram
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['program_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_loyalty_program" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'program_id' is set
        if ('program_id' not in params or
                params['program_id'] is None):
            raise ValueError("Missing the required parameter `program_id` when calling `get_loyalty_program`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'program_id' in params:
            path_params['programID'] = params['program_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/loyalty_programs/{programID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LoyaltyProgram',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_loyalty_programs(self, **kwargs):  # noqa: E501
        """List all loyalty Programs  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_loyalty_programs(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_loyalty_programs_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_loyalty_programs_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_loyalty_programs_with_http_info(self, **kwargs):  # noqa: E501
        """List all loyalty Programs  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_loyalty_programs_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_loyalty_programs" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/loyalty_programs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2008',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_referrals(self, application_id, campaign_id, **kwargs):  # noqa: E501
        """List Referrals  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_referrals(application_id, campaign_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :param int campaign_id:  (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str code: Filter results performing case-insensitive matching against the referral code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches referrals in which the expiry date is set and in the past. The second matches referrals in which start date is null or in the past and expiry date is null or in the future, the third matches referrals in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only referrals where `usageCounter < usageLimit` will be returned, \"false\" will return only referrals where `usageCounter >= usageLimit`. 
        :param str advocate: Filter results by match with a profile id specified in the referral's AdvocateProfileIntegrationId field
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_referrals_with_http_info(application_id, campaign_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_referrals_with_http_info(application_id, campaign_id, **kwargs)  # noqa: E501
            return data

    def get_referrals_with_http_info(self, application_id, campaign_id, **kwargs):  # noqa: E501
        """List Referrals  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_referrals_with_http_info(application_id, campaign_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :param int campaign_id:  (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str code: Filter results performing case-insensitive matching against the referral code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches referrals in which the expiry date is set and in the past. The second matches referrals in which start date is null or in the past and expiry date is null or in the future, the third matches referrals in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only referrals where `usageCounter < usageLimit` will be returned, \"false\" will return only referrals where `usageCounter >= usageLimit`. 
        :param str advocate: Filter results by match with a profile id specified in the referral's AdvocateProfileIntegrationId field
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'campaign_id', 'page_size', 'skip', 'sort', 'code', 'created_before', 'created_after', 'valid', 'usable', 'advocate']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_referrals" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `get_referrals`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if ('campaign_id' not in params or
                params['campaign_id'] is None):
            raise ValueError("Missing the required parameter `campaign_id` when calling `get_referrals`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501
        if 'campaign_id' in params:
            path_params['campaignId'] = params['campaign_id']  # noqa: E501

        query_params = []
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'code' in params:
            query_params.append(('code', params['code']))  # noqa: E501
        if 'created_before' in params:
            query_params.append(('createdBefore', params['created_before']))  # noqa: E501
        if 'created_after' in params:
            query_params.append(('createdAfter', params['created_after']))  # noqa: E501
        if 'valid' in params:
            query_params.append(('valid', params['valid']))  # noqa: E501
        if 'usable' in params:
            query_params.append(('usable', params['usable']))  # noqa: E501
        if 'advocate' in params:
            query_params.append(('advocate', params['advocate']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/referrals', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2006',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_referrals_without_total_count(self, application_id, campaign_id, **kwargs):  # noqa: E501
        """List Referrals  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_referrals_without_total_count(application_id, campaign_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :param int campaign_id:  (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str code: Filter results performing case-insensitive matching against the referral code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches referrals in which the expiry date is set and in the past. The second matches referrals in which start date is null or in the past and expiry date is null or in the future, the third matches referrals in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only referrals where `usageCounter < usageLimit` will be returned, \"false\" will return only referrals where `usageCounter >= usageLimit`. 
        :param str advocate: Filter results by match with a profile id specified in the referral's AdvocateProfileIntegrationId field
        :return: InlineResponse2007
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_referrals_without_total_count_with_http_info(application_id, campaign_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_referrals_without_total_count_with_http_info(application_id, campaign_id, **kwargs)  # noqa: E501
            return data

    def get_referrals_without_total_count_with_http_info(self, application_id, campaign_id, **kwargs):  # noqa: E501
        """List Referrals  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_referrals_without_total_count_with_http_info(application_id, campaign_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :param int campaign_id:  (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str code: Filter results performing case-insensitive matching against the referral code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches referrals in which the expiry date is set and in the past. The second matches referrals in which start date is null or in the past and expiry date is null or in the future, the third matches referrals in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only referrals where `usageCounter < usageLimit` will be returned, \"false\" will return only referrals where `usageCounter >= usageLimit`. 
        :param str advocate: Filter results by match with a profile id specified in the referral's AdvocateProfileIntegrationId field
        :return: InlineResponse2007
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'campaign_id', 'page_size', 'skip', 'sort', 'code', 'created_before', 'created_after', 'valid', 'usable', 'advocate']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_referrals_without_total_count" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `get_referrals_without_total_count`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if ('campaign_id' not in params or
                params['campaign_id'] is None):
            raise ValueError("Missing the required parameter `campaign_id` when calling `get_referrals_without_total_count`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501
        if 'campaign_id' in params:
            path_params['campaignId'] = params['campaign_id']  # noqa: E501

        query_params = []
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'code' in params:
            query_params.append(('code', params['code']))  # noqa: E501
        if 'created_before' in params:
            query_params.append(('createdBefore', params['created_before']))  # noqa: E501
        if 'created_after' in params:
            query_params.append(('createdAfter', params['created_after']))  # noqa: E501
        if 'valid' in params:
            query_params.append(('valid', params['valid']))  # noqa: E501
        if 'usable' in params:
            query_params.append(('usable', params['usable']))  # noqa: E501
        if 'advocate' in params:
            query_params.append(('advocate', params['advocate']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/referrals/no_total', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2007',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_role(self, role_id, **kwargs):  # noqa: E501
        """Get information for the specified role.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_role(role_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int role_id:  (required)
        :return: Role
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_role_with_http_info(role_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_role_with_http_info(role_id, **kwargs)  # noqa: E501
            return data

    def get_role_with_http_info(self, role_id, **kwargs):  # noqa: E501
        """Get information for the specified role.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_role_with_http_info(role_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int role_id:  (required)
        :return: Role
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['role_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_role" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'role_id' is set
        if ('role_id' not in params or
                params['role_id'] is None):
            raise ValueError("Missing the required parameter `role_id` when calling `get_role`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'role_id' in params:
            path_params['roleId'] = params['role_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/roles/{roleId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Role',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ruleset(self, application_id, campaign_id, ruleset_id, **kwargs):  # noqa: E501
        """Get a Ruleset  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ruleset(application_id, campaign_id, ruleset_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param int campaign_id:  (required)
        :param int ruleset_id:  (required)
        :return: Ruleset
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_ruleset_with_http_info(application_id, campaign_id, ruleset_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_ruleset_with_http_info(application_id, campaign_id, ruleset_id, **kwargs)  # noqa: E501
            return data

    def get_ruleset_with_http_info(self, application_id, campaign_id, ruleset_id, **kwargs):  # noqa: E501
        """Get a Ruleset  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ruleset_with_http_info(application_id, campaign_id, ruleset_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param int campaign_id:  (required)
        :param int ruleset_id:  (required)
        :return: Ruleset
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'campaign_id', 'ruleset_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ruleset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `get_ruleset`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if ('campaign_id' not in params or
                params['campaign_id'] is None):
            raise ValueError("Missing the required parameter `campaign_id` when calling `get_ruleset`")  # noqa: E501
        # verify the required parameter 'ruleset_id' is set
        if ('ruleset_id' not in params or
                params['ruleset_id'] is None):
            raise ValueError("Missing the required parameter `ruleset_id` when calling `get_ruleset`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501
        if 'campaign_id' in params:
            path_params['campaignId'] = params['campaign_id']  # noqa: E501
        if 'ruleset_id' in params:
            path_params['rulesetId'] = params['ruleset_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/rulesets/{rulesetId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Ruleset',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_rulesets(self, application_id, campaign_id, **kwargs):  # noqa: E501
        """List Campaign Rulesets  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_rulesets(application_id, campaign_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :param int campaign_id:  (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :return: InlineResponse2004
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_rulesets_with_http_info(application_id, campaign_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_rulesets_with_http_info(application_id, campaign_id, **kwargs)  # noqa: E501
            return data

    def get_rulesets_with_http_info(self, application_id, campaign_id, **kwargs):  # noqa: E501
        """List Campaign Rulesets  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_rulesets_with_http_info(application_id, campaign_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :param int campaign_id:  (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :return: InlineResponse2004
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'campaign_id', 'page_size', 'skip', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_rulesets" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `get_rulesets`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if ('campaign_id' not in params or
                params['campaign_id'] is None):
            raise ValueError("Missing the required parameter `campaign_id` when calling `get_rulesets`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501
        if 'campaign_id' in params:
            path_params['campaignId'] = params['campaign_id']  # noqa: E501

        query_params = []
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/rulesets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2004',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user(self, user_id, **kwargs):  # noqa: E501
        """Get a single User  # noqa: E501

        Retrieves the data (including an invitation code) for a user. Non-admin users can only get themselves.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int user_id:  (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_user_with_http_info(user_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_user_with_http_info(user_id, **kwargs)  # noqa: E501
            return data

    def get_user_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get a single User  # noqa: E501

        Retrieves the data (including an invitation code) for a user. Non-admin users can only get themselves.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int user_id:  (required)
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'user_id' is set
        if ('user_id' not in params or
                params['user_id'] is None):
            raise ValueError("Missing the required parameter `user_id` when calling `get_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in params:
            path_params['userId'] = params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{userId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_users(self, **kwargs):  # noqa: E501
        """List Users in your account  # noqa: E501

        Retrieve all users in your account.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_users(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :return: InlineResponse20024
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_users_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_users_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_users_with_http_info(self, **kwargs):  # noqa: E501
        """List Users in your account  # noqa: E501

        Retrieve all users in your account.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_users_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :return: InlineResponse20024
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page_size', 'skip', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_users" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/users', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20024',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_webhook(self, webhook_id, **kwargs):  # noqa: E501
        """Get Webhook  # noqa: E501

        Returns an webhook by its id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_webhook(webhook_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int webhook_id: (required)
        :return: Webhook
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_webhook_with_http_info(webhook_id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_webhook_with_http_info(webhook_id, **kwargs)  # noqa: E501
            return data

    def get_webhook_with_http_info(self, webhook_id, **kwargs):  # noqa: E501
        """Get Webhook  # noqa: E501

        Returns an webhook by its id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_webhook_with_http_info(webhook_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int webhook_id: (required)
        :return: Webhook
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['webhook_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_webhook" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'webhook_id' is set
        if ('webhook_id' not in params or
                params['webhook_id'] is None):
            raise ValueError("Missing the required parameter `webhook_id` when calling `get_webhook`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'webhook_id' in params:
            path_params['webhookId'] = params['webhook_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/webhooks/{webhookId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Webhook',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_webhook_activation_logs(self, **kwargs):  # noqa: E501
        """List Webhook activation Log Entries  # noqa: E501

        Webhook activation log entries would be created as soon as an integration request triggered an effect with a webhook  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_webhook_activation_logs(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str integration_request_uuid: Filter results by integration request UUID.
        :param float webhook_id: Filter results by Webhook.
        :param float application_id:
        :param float campaign_id: Filter results by campaign.
        :param datetime created_before: Only return events created before this date.
        :param datetime created_after: Filter results where request and response times to return entries after parameter value, expected to be an RFC3339 timestamp string.
        :return: InlineResponse20021
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_webhook_activation_logs_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_webhook_activation_logs_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_webhook_activation_logs_with_http_info(self, **kwargs):  # noqa: E501
        """List Webhook activation Log Entries  # noqa: E501

        Webhook activation log entries would be created as soon as an integration request triggered an effect with a webhook  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_webhook_activation_logs_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str integration_request_uuid: Filter results by integration request UUID.
        :param float webhook_id: Filter results by Webhook.
        :param float application_id:
        :param float campaign_id: Filter results by campaign.
        :param datetime created_before: Only return events created before this date.
        :param datetime created_after: Filter results where request and response times to return entries after parameter value, expected to be an RFC3339 timestamp string.
        :return: InlineResponse20021
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page_size', 'skip', 'sort', 'integration_request_uuid', 'webhook_id', 'application_id', 'campaign_id', 'created_before', 'created_after']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_webhook_activation_logs" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'integration_request_uuid' in params:
            query_params.append(('integrationRequestUuid', params['integration_request_uuid']))  # noqa: E501
        if 'webhook_id' in params:
            query_params.append(('webhookId', params['webhook_id']))  # noqa: E501
        if 'application_id' in params:
            query_params.append(('applicationId', params['application_id']))  # noqa: E501
        if 'campaign_id' in params:
            query_params.append(('campaignId', params['campaign_id']))  # noqa: E501
        if 'created_before' in params:
            query_params.append(('createdBefore', params['created_before']))  # noqa: E501
        if 'created_after' in params:
            query_params.append(('createdAfter', params['created_after']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/webhook_activation_logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20021',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_webhook_logs(self, **kwargs):  # noqa: E501
        """List Webhook Log Entries  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_webhook_logs(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str status: Filter results by HTTP status codes.
        :param float webhook_id: Filter results by Webhook.
        :param float application_id:
        :param float campaign_id: Filter results by campaign.
        :param str request_uuid: Filter results by request UUID.
        :param datetime created_before: Filter results where request and response times to return entries before parameter value, expected to be an RFC3339 timestamp string.
        :param datetime created_after: Filter results where request and response times to return entries after parameter value, expected to be an RFC3339 timestamp string.
        :return: InlineResponse20022
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_webhook_logs_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_webhook_logs_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_webhook_logs_with_http_info(self, **kwargs):  # noqa: E501
        """List Webhook Log Entries  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_webhook_logs_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str status: Filter results by HTTP status codes.
        :param float webhook_id: Filter results by Webhook.
        :param float application_id:
        :param float campaign_id: Filter results by campaign.
        :param str request_uuid: Filter results by request UUID.
        :param datetime created_before: Filter results where request and response times to return entries before parameter value, expected to be an RFC3339 timestamp string.
        :param datetime created_after: Filter results where request and response times to return entries after parameter value, expected to be an RFC3339 timestamp string.
        :return: InlineResponse20022
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page_size', 'skip', 'sort', 'status', 'webhook_id', 'application_id', 'campaign_id', 'request_uuid', 'created_before', 'created_after']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_webhook_logs" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'status' in params:
            query_params.append(('status', params['status']))  # noqa: E501
        if 'webhook_id' in params:
            query_params.append(('webhookId', params['webhook_id']))  # noqa: E501
        if 'application_id' in params:
            query_params.append(('applicationId', params['application_id']))  # noqa: E501
        if 'campaign_id' in params:
            query_params.append(('campaignId', params['campaign_id']))  # noqa: E501
        if 'request_uuid' in params:
            query_params.append(('requestUuid', params['request_uuid']))  # noqa: E501
        if 'created_before' in params:
            query_params.append(('createdBefore', params['created_before']))  # noqa: E501
        if 'created_after' in params:
            query_params.append(('createdAfter', params['created_after']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/webhook_logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20022',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_webhooks(self, **kwargs):  # noqa: E501
        """List Webhooks  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_webhooks(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str application_ids: Filter by one or more application ids separated by comma
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :return: InlineResponse20020
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_webhooks_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_webhooks_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_webhooks_with_http_info(self, **kwargs):  # noqa: E501
        """List Webhooks  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_webhooks_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str application_ids: Filter by one or more application ids separated by comma
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :return: InlineResponse20020
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_ids', 'sort', 'page_size', 'skip']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_webhooks" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'application_ids' in params:
            query_params.append(('applicationIds', params['application_ids']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/webhooks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20020',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def refresh_analytics(self, **kwargs):  # noqa: E501
        """Trigger refresh on stale analytics.  # noqa: E501

        Should be used to trigger a manual refresh of analytics.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.refresh_analytics(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.refresh_analytics_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.refresh_analytics_with_http_info(**kwargs)  # noqa: E501
            return data

    def refresh_analytics_with_http_info(self, **kwargs):  # noqa: E501
        """Trigger refresh on stale analytics.  # noqa: E501

        Should be used to trigger a manual refresh of analytics.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.refresh_analytics_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method refresh_analytics" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/refresh_analytics', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_loyalty_points(self, program_id, integration_id, body, **kwargs):  # noqa: E501
        """Deduct points in a certain loyalty program for the specified customer  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_loyalty_points(program_id, integration_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str program_id: (required)
        :param str integration_id: (required)
        :param LoyaltyPoints body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.remove_loyalty_points_with_http_info(program_id, integration_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.remove_loyalty_points_with_http_info(program_id, integration_id, body, **kwargs)  # noqa: E501
            return data

    def remove_loyalty_points_with_http_info(self, program_id, integration_id, body, **kwargs):  # noqa: E501
        """Deduct points in a certain loyalty program for the specified customer  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_loyalty_points_with_http_info(program_id, integration_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str program_id: (required)
        :param str integration_id: (required)
        :param LoyaltyPoints body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['program_id', 'integration_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_loyalty_points" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'program_id' is set
        if ('program_id' not in params or
                params['program_id'] is None):
            raise ValueError("Missing the required parameter `program_id` when calling `remove_loyalty_points`")  # noqa: E501
        # verify the required parameter 'integration_id' is set
        if ('integration_id' not in params or
                params['integration_id'] is None):
            raise ValueError("Missing the required parameter `integration_id` when calling `remove_loyalty_points`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `remove_loyalty_points`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'program_id' in params:
            path_params['programID'] = params['program_id']  # noqa: E501
        if 'integration_id' in params:
            path_params['integrationID'] = params['integration_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/loyalty_programs/{programID}/profile/{integrationID}/deduct_points', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def reset_password(self, body, **kwargs):  # noqa: E501
        """Reset password  # noqa: E501

        Consumes the supplied password reset token and updates the password for the associated account.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reset_password(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NewPassword body: (required)
        :return: NewPassword
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.reset_password_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.reset_password_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def reset_password_with_http_info(self, body, **kwargs):  # noqa: E501
        """Reset password  # noqa: E501

        Consumes the supplied password reset token and updates the password for the associated account.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reset_password_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param NewPassword body: (required)
        :return: NewPassword
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reset_password" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `reset_password`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/reset_password', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NewPassword',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_coupons_advanced(self, application_id, campaign_id, body, **kwargs):  # noqa: E501
        """Get a list of the coupons that match the given attributes  # noqa: E501

        Gets a list of all the coupons with attributes matching the query criteria   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_coupons_advanced(application_id, campaign_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param int campaign_id:  (required)
        :param AttributeQuery body: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :param str batch_id: Filter results by batches of coupons
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_coupons_advanced_with_http_info(application_id, campaign_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.search_coupons_advanced_with_http_info(application_id, campaign_id, body, **kwargs)  # noqa: E501
            return data

    def search_coupons_advanced_with_http_info(self, application_id, campaign_id, body, **kwargs):  # noqa: E501
        """Get a list of the coupons that match the given attributes  # noqa: E501

        Gets a list of all the coupons with attributes matching the query criteria   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_coupons_advanced_with_http_info(application_id, campaign_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param int campaign_id:  (required)
        :param AttributeQuery body: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :param str batch_id: Filter results by batches of coupons
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'campaign_id', 'body', 'page_size', 'skip', 'sort', 'value', 'created_before', 'created_after', 'valid', 'usable', 'referral_id', 'recipient_integration_id', 'exact_match', 'batch_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_coupons_advanced" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `search_coupons_advanced`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if ('campaign_id' not in params or
                params['campaign_id'] is None):
            raise ValueError("Missing the required parameter `campaign_id` when calling `search_coupons_advanced`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `search_coupons_advanced`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501
        if 'campaign_id' in params:
            path_params['campaignId'] = params['campaign_id']  # noqa: E501

        query_params = []
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'value' in params:
            query_params.append(('value', params['value']))  # noqa: E501
        if 'created_before' in params:
            query_params.append(('createdBefore', params['created_before']))  # noqa: E501
        if 'created_after' in params:
            query_params.append(('createdAfter', params['created_after']))  # noqa: E501
        if 'valid' in params:
            query_params.append(('valid', params['valid']))  # noqa: E501
        if 'usable' in params:
            query_params.append(('usable', params['usable']))  # noqa: E501
        if 'referral_id' in params:
            query_params.append(('referralId', params['referral_id']))  # noqa: E501
        if 'recipient_integration_id' in params:
            query_params.append(('recipientIntegrationId', params['recipient_integration_id']))  # noqa: E501
        if 'exact_match' in params:
            query_params.append(('exactMatch', params['exact_match']))  # noqa: E501
        if 'batch_id' in params:
            query_params.append(('batchId', params['batch_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons_search_advanced', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2001',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_coupons_advanced_application_wide(self, application_id, body, **kwargs):  # noqa: E501
        """Get a list of the coupons that match the given attributes in all active campaigns of an application  # noqa: E501

        Gets a list of all the coupons with attributes matching the query criteria in all active campaigns of an application   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_coupons_advanced_application_wide(application_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param AttributeQuery body: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param str batch_id: Filter results by batches of coupons
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :param str campaign_state: Filter results by the state of the campaign.
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_coupons_advanced_application_wide_with_http_info(application_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.search_coupons_advanced_application_wide_with_http_info(application_id, body, **kwargs)  # noqa: E501
            return data

    def search_coupons_advanced_application_wide_with_http_info(self, application_id, body, **kwargs):  # noqa: E501
        """Get a list of the coupons that match the given attributes in all active campaigns of an application  # noqa: E501

        Gets a list of all the coupons with attributes matching the query criteria in all active campaigns of an application   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_coupons_advanced_application_wide_with_http_info(application_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param AttributeQuery body: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param str batch_id: Filter results by batches of coupons
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :param str campaign_state: Filter results by the state of the campaign.
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'body', 'page_size', 'skip', 'sort', 'value', 'created_before', 'created_after', 'valid', 'usable', 'referral_id', 'recipient_integration_id', 'batch_id', 'exact_match', 'campaign_state']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_coupons_advanced_application_wide" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `search_coupons_advanced_application_wide`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `search_coupons_advanced_application_wide`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501

        query_params = []
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'value' in params:
            query_params.append(('value', params['value']))  # noqa: E501
        if 'created_before' in params:
            query_params.append(('createdBefore', params['created_before']))  # noqa: E501
        if 'created_after' in params:
            query_params.append(('createdAfter', params['created_after']))  # noqa: E501
        if 'valid' in params:
            query_params.append(('valid', params['valid']))  # noqa: E501
        if 'usable' in params:
            query_params.append(('usable', params['usable']))  # noqa: E501
        if 'referral_id' in params:
            query_params.append(('referralId', params['referral_id']))  # noqa: E501
        if 'recipient_integration_id' in params:
            query_params.append(('recipientIntegrationId', params['recipient_integration_id']))  # noqa: E501
        if 'batch_id' in params:
            query_params.append(('batchId', params['batch_id']))  # noqa: E501
        if 'exact_match' in params:
            query_params.append(('exactMatch', params['exact_match']))  # noqa: E501
        if 'campaign_state' in params:
            query_params.append(('campaignState', params['campaign_state']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/coupons_search_advanced', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2001',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_coupons_advanced_application_wide_without_total_count(self, application_id, body, **kwargs):  # noqa: E501
        """Get a list of the coupons that match the given attributes in all active campaigns of an application  # noqa: E501

        Gets a list of all the coupons with attributes matching the query criteria in all active campaigns of an application   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_coupons_advanced_application_wide_without_total_count(application_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param AttributeQuery body: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param str batch_id: Filter results by batches of coupons
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :param str campaign_state: Filter results by the state of the campaign.
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_coupons_advanced_application_wide_without_total_count_with_http_info(application_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.search_coupons_advanced_application_wide_without_total_count_with_http_info(application_id, body, **kwargs)  # noqa: E501
            return data

    def search_coupons_advanced_application_wide_without_total_count_with_http_info(self, application_id, body, **kwargs):  # noqa: E501
        """Get a list of the coupons that match the given attributes in all active campaigns of an application  # noqa: E501

        Gets a list of all the coupons with attributes matching the query criteria in all active campaigns of an application   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_coupons_advanced_application_wide_without_total_count_with_http_info(application_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param AttributeQuery body: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param str batch_id: Filter results by batches of coupons
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :param str campaign_state: Filter results by the state of the campaign.
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'body', 'page_size', 'skip', 'sort', 'value', 'created_before', 'created_after', 'valid', 'usable', 'referral_id', 'recipient_integration_id', 'batch_id', 'exact_match', 'campaign_state']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_coupons_advanced_application_wide_without_total_count" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `search_coupons_advanced_application_wide_without_total_count`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `search_coupons_advanced_application_wide_without_total_count`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501

        query_params = []
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'value' in params:
            query_params.append(('value', params['value']))  # noqa: E501
        if 'created_before' in params:
            query_params.append(('createdBefore', params['created_before']))  # noqa: E501
        if 'created_after' in params:
            query_params.append(('createdAfter', params['created_after']))  # noqa: E501
        if 'valid' in params:
            query_params.append(('valid', params['valid']))  # noqa: E501
        if 'usable' in params:
            query_params.append(('usable', params['usable']))  # noqa: E501
        if 'referral_id' in params:
            query_params.append(('referralId', params['referral_id']))  # noqa: E501
        if 'recipient_integration_id' in params:
            query_params.append(('recipientIntegrationId', params['recipient_integration_id']))  # noqa: E501
        if 'batch_id' in params:
            query_params.append(('batchId', params['batch_id']))  # noqa: E501
        if 'exact_match' in params:
            query_params.append(('exactMatch', params['exact_match']))  # noqa: E501
        if 'campaign_state' in params:
            query_params.append(('campaignState', params['campaign_state']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/coupons_search_advanced/no_total', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2005',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_coupons_advanced_without_total_count(self, application_id, campaign_id, body, **kwargs):  # noqa: E501
        """Get a list of the coupons that match the given attributes  # noqa: E501

        Gets a list of all the coupons with attributes matching the query criteria   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_coupons_advanced_without_total_count(application_id, campaign_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param int campaign_id:  (required)
        :param AttributeQuery body: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :param str batch_id: Filter results by batches of coupons
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_coupons_advanced_without_total_count_with_http_info(application_id, campaign_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.search_coupons_advanced_without_total_count_with_http_info(application_id, campaign_id, body, **kwargs)  # noqa: E501
            return data

    def search_coupons_advanced_without_total_count_with_http_info(self, application_id, campaign_id, body, **kwargs):  # noqa: E501
        """Get a list of the coupons that match the given attributes  # noqa: E501

        Gets a list of all the coupons with attributes matching the query criteria   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_coupons_advanced_without_total_count_with_http_info(application_id, campaign_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param int campaign_id:  (required)
        :param AttributeQuery body: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :param str batch_id: Filter results by batches of coupons
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'campaign_id', 'body', 'page_size', 'skip', 'sort', 'value', 'created_before', 'created_after', 'valid', 'usable', 'referral_id', 'recipient_integration_id', 'exact_match', 'batch_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_coupons_advanced_without_total_count" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `search_coupons_advanced_without_total_count`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if ('campaign_id' not in params or
                params['campaign_id'] is None):
            raise ValueError("Missing the required parameter `campaign_id` when calling `search_coupons_advanced_without_total_count`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `search_coupons_advanced_without_total_count`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501
        if 'campaign_id' in params:
            path_params['campaignId'] = params['campaign_id']  # noqa: E501

        query_params = []
        if 'page_size' in params:
            query_params.append(('pageSize', params['page_size']))  # noqa: E501
        if 'skip' in params:
            query_params.append(('skip', params['skip']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'value' in params:
            query_params.append(('value', params['value']))  # noqa: E501
        if 'created_before' in params:
            query_params.append(('createdBefore', params['created_before']))  # noqa: E501
        if 'created_after' in params:
            query_params.append(('createdAfter', params['created_after']))  # noqa: E501
        if 'valid' in params:
            query_params.append(('valid', params['valid']))  # noqa: E501
        if 'usable' in params:
            query_params.append(('usable', params['usable']))  # noqa: E501
        if 'referral_id' in params:
            query_params.append(('referralId', params['referral_id']))  # noqa: E501
        if 'recipient_integration_id' in params:
            query_params.append(('recipientIntegrationId', params['recipient_integration_id']))  # noqa: E501
        if 'exact_match' in params:
            query_params.append(('exactMatch', params['exact_match']))  # noqa: E501
        if 'batch_id' in params:
            query_params.append(('batchId', params['batch_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons_search_advanced/no_total', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2005',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def set_account_limits(self, account_id, body, **kwargs):  # noqa: E501
        """Set account limits  # noqa: E501

        sets account limits    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_account_limits(account_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id:  (required)
        :param AccountLimits body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.set_account_limits_with_http_info(account_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.set_account_limits_with_http_info(account_id, body, **kwargs)  # noqa: E501
            return data

    def set_account_limits_with_http_info(self, account_id, body, **kwargs):  # noqa: E501
        """Set account limits  # noqa: E501

        sets account limits    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.set_account_limits_with_http_info(account_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int account_id:  (required)
        :param AccountLimits body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['account_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method set_account_limits" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'account_id' is set
        if ('account_id' not in params or
                params['account_id'] is None):
            raise ValueError("Missing the required parameter `account_id` when calling `set_account_limits`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `set_account_limits`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in params:
            path_params['accountId'] = params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{accountId}/limits', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_campaign(self, application_id, campaign_id, body, **kwargs):  # noqa: E501
        """Update a Campaign  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_campaign(application_id, campaign_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param int campaign_id:  (required)
        :param UpdateCampaign body: (required)
        :return: Campaign
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_campaign_with_http_info(application_id, campaign_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_campaign_with_http_info(application_id, campaign_id, body, **kwargs)  # noqa: E501
            return data

    def update_campaign_with_http_info(self, application_id, campaign_id, body, **kwargs):  # noqa: E501
        """Update a Campaign  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_campaign_with_http_info(application_id, campaign_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param int campaign_id:  (required)
        :param UpdateCampaign body: (required)
        :return: Campaign
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'campaign_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_campaign" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `update_campaign`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if ('campaign_id' not in params or
                params['campaign_id'] is None):
            raise ValueError("Missing the required parameter `campaign_id` when calling `update_campaign`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_campaign`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501
        if 'campaign_id' in params:
            path_params['campaignId'] = params['campaign_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Campaign',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_campaign_set(self, application_id, body, **kwargs):  # noqa: E501
        """Update a Campaign Set  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_campaign_set(application_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :param NewCampaignSet body: (required)
        :return: CampaignSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_campaign_set_with_http_info(application_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_campaign_set_with_http_info(application_id, body, **kwargs)  # noqa: E501
            return data

    def update_campaign_set_with_http_info(self, application_id, body, **kwargs):  # noqa: E501
        """Update a Campaign Set  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_campaign_set_with_http_info(application_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :param NewCampaignSet body: (required)
        :return: CampaignSet
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_campaign_set" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `update_campaign_set`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_campaign_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaign_set', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CampaignSet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_coupon(self, application_id, campaign_id, coupon_id, body, **kwargs):  # noqa: E501
        """Update a Coupon  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_coupon(application_id, campaign_id, coupon_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :param int campaign_id:  (required)
        :param str coupon_id: The ID of the coupon code to update (required)
        :param UpdateCoupon body: (required)
        :return: Coupon
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_coupon_with_http_info(application_id, campaign_id, coupon_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_coupon_with_http_info(application_id, campaign_id, coupon_id, body, **kwargs)  # noqa: E501
            return data

    def update_coupon_with_http_info(self, application_id, campaign_id, coupon_id, body, **kwargs):  # noqa: E501
        """Update a Coupon  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_coupon_with_http_info(application_id, campaign_id, coupon_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id:  (required)
        :param int campaign_id:  (required)
        :param str coupon_id: The ID of the coupon code to update (required)
        :param UpdateCoupon body: (required)
        :return: Coupon
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'campaign_id', 'coupon_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_coupon" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `update_coupon`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if ('campaign_id' not in params or
                params['campaign_id'] is None):
            raise ValueError("Missing the required parameter `campaign_id` when calling `update_coupon`")  # noqa: E501
        # verify the required parameter 'coupon_id' is set
        if ('coupon_id' not in params or
                params['coupon_id'] is None):
            raise ValueError("Missing the required parameter `coupon_id` when calling `update_coupon`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_coupon`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501
        if 'campaign_id' in params:
            path_params['campaignId'] = params['campaign_id']  # noqa: E501
        if 'coupon_id' in params:
            path_params['couponId'] = params['coupon_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons/{couponId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Coupon',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_coupon_batch(self, application_id, campaign_id, body, **kwargs):  # noqa: E501
        """Update a Batch of Coupons  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_coupon_batch(application_id, campaign_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param int campaign_id:  (required)
        :param UpdateCouponBatch body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_coupon_batch_with_http_info(application_id, campaign_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_coupon_batch_with_http_info(application_id, campaign_id, body, **kwargs)  # noqa: E501
            return data

    def update_coupon_batch_with_http_info(self, application_id, campaign_id, body, **kwargs):  # noqa: E501
        """Update a Batch of Coupons  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_coupon_batch_with_http_info(application_id, campaign_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param int campaign_id:  (required)
        :param UpdateCouponBatch body: (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'campaign_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_coupon_batch" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `update_coupon_batch`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if ('campaign_id' not in params or
                params['campaign_id'] is None):
            raise ValueError("Missing the required parameter `campaign_id` when calling `update_coupon_batch`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_coupon_batch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501
        if 'campaign_id' in params:
            path_params['campaignId'] = params['campaign_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_ruleset(self, application_id, campaign_id, ruleset_id, body, **kwargs):  # noqa: E501
        """Update a Ruleset  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_ruleset(application_id, campaign_id, ruleset_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param int campaign_id:  (required)
        :param int ruleset_id:  (required)
        :param NewRuleset body: (required)
        :return: Ruleset
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.update_ruleset_with_http_info(application_id, campaign_id, ruleset_id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.update_ruleset_with_http_info(application_id, campaign_id, ruleset_id, body, **kwargs)  # noqa: E501
            return data

    def update_ruleset_with_http_info(self, application_id, campaign_id, ruleset_id, body, **kwargs):  # noqa: E501
        """Update a Ruleset  # noqa: E501

          # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_ruleset_with_http_info(application_id, campaign_id, ruleset_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int application_id: (required)
        :param int campaign_id:  (required)
        :param int ruleset_id:  (required)
        :param NewRuleset body: (required)
        :return: Ruleset
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['application_id', 'campaign_id', 'ruleset_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_ruleset" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'application_id' is set
        if ('application_id' not in params or
                params['application_id'] is None):
            raise ValueError("Missing the required parameter `application_id` when calling `update_ruleset`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if ('campaign_id' not in params or
                params['campaign_id'] is None):
            raise ValueError("Missing the required parameter `campaign_id` when calling `update_ruleset`")  # noqa: E501
        # verify the required parameter 'ruleset_id' is set
        if ('ruleset_id' not in params or
                params['ruleset_id'] is None):
            raise ValueError("Missing the required parameter `ruleset_id` when calling `update_ruleset`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `update_ruleset`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in params:
            path_params['applicationId'] = params['application_id']  # noqa: E501
        if 'campaign_id' in params:
            path_params['campaignId'] = params['campaign_id']  # noqa: E501
        if 'ruleset_id' in params:
            path_params['rulesetId'] = params['ruleset_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/rulesets/{rulesetId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Ruleset',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
