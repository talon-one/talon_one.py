# coding: utf-8

"""
    Talon.One API

    The Talon.One API is used to manage applications and campaigns, as well as to integrate with your application. The operations in the _Integration API_ section are used to integrate with our platform, while the other operations are used to manage applications and campaigns.  ### Where is the API?  The API is available at the same hostname as these docs. For example, if you are reading this page at `https://mycompany.talon.one/docs/api/`, the URL for the [updateCustomerProfile][] operation is `https://mycompany.talon.one/v1/customer_profiles/id`  [updateCustomerProfile]: #operation--v1-customer_profiles--integrationId--put   # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Generated by: https://openapi-generator.tech
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from talon_one.api_client import ApiClient
from talon_one.exceptions import (
    ApiTypeError,
    ApiValueError
)


class ManagementApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_loyalty_points(self, program_id, integration_id, body, **kwargs):  # noqa: E501
        """Add points in a certain loyalty program for the specified customer  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_loyalty_points(program_id, integration_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str program_id: (required)
        :param str integration_id: (required)
        :param LoyaltyPoints body: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.add_loyalty_points_with_http_info(program_id, integration_id, body, **kwargs)  # noqa: E501

    def add_loyalty_points_with_http_info(self, program_id, integration_id, body, **kwargs):  # noqa: E501
        """Add points in a certain loyalty program for the specified customer  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_loyalty_points_with_http_info(program_id, integration_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str program_id: (required)
        :param str integration_id: (required)
        :param LoyaltyPoints body: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['program_id', 'integration_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_loyalty_points" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'program_id' is set
        if self.api_client.client_side_validation and ('program_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['program_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `program_id` when calling `add_loyalty_points`")  # noqa: E501
        # verify the required parameter 'integration_id' is set
        if self.api_client.client_side_validation and ('integration_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['integration_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `integration_id` when calling `add_loyalty_points`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `add_loyalty_points`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'program_id' in local_var_params:
            path_params['programID'] = local_var_params['program_id']  # noqa: E501
        if 'integration_id' in local_var_params:
            path_params['integrationID'] = local_var_params['integration_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/loyalty_programs/{programID}/profile/{integrationID}/add_points', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def copy_campaign_to_applications(self, application_id, campaign_id, body, **kwargs):  # noqa: E501
        """Copy the campaign into every specified application  # noqa: E501

        Copy the campaign into every specified application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_campaign_to_applications(application_id, campaign_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param CampaignCopy body: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.copy_campaign_to_applications_with_http_info(application_id, campaign_id, body, **kwargs)  # noqa: E501

    def copy_campaign_to_applications_with_http_info(self, application_id, campaign_id, body, **kwargs):  # noqa: E501
        """Copy the campaign into every specified application  # noqa: E501

        Copy the campaign into every specified application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.copy_campaign_to_applications_with_http_info(application_id, campaign_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param CampaignCopy body: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse2003, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'campaign_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method copy_campaign_to_applications" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `copy_campaign_to_applications`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if self.api_client.client_side_validation and ('campaign_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['campaign_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `campaign_id` when calling `copy_campaign_to_applications`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `copy_campaign_to_applications`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501
        if 'campaign_id' in local_var_params:
            path_params['campaignId'] = local_var_params['campaign_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/copy', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2003',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_additional_cost(self, body, **kwargs):  # noqa: E501
        """Define a new additional cost  # noqa: E501

        Defines a new _additional cost_ in this account.  These additional costs are shared across all applications in your account, and are never required.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_additional_cost(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param NewAdditionalCost body: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AccountAdditionalCost
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_additional_cost_with_http_info(body, **kwargs)  # noqa: E501

    def create_additional_cost_with_http_info(self, body, **kwargs):  # noqa: E501
        """Define a new additional cost  # noqa: E501

        Defines a new _additional cost_ in this account.  These additional costs are shared across all applications in your account, and are never required.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_additional_cost_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param NewAdditionalCost body: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AccountAdditionalCost, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_additional_cost" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `create_additional_cost`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/additional_costs', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccountAdditionalCost',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_attribute(self, body, **kwargs):  # noqa: E501
        """Define a new custom attribute  # noqa: E501

        Defines a new _custom attribute_ in this account. Custom attributes allow you to attach new fields to Talon.One domain objects like campaigns, coupons, customers and so on. These attributes can then be given values when creating / updating these objects, and these values can be used in your campaign rules. For example, you could define a `zipCode` field for customer sessions, and add a rule to your campaign that only allows certain ZIP codes.  These attributes are shared across all applications in your account, and are never required.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_attribute(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param NewAttribute body: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Attribute
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_attribute_with_http_info(body, **kwargs)  # noqa: E501

    def create_attribute_with_http_info(self, body, **kwargs):  # noqa: E501
        """Define a new custom attribute  # noqa: E501

        Defines a new _custom attribute_ in this account. Custom attributes allow you to attach new fields to Talon.One domain objects like campaigns, coupons, customers and so on. These attributes can then be given values when creating / updating these objects, and these values can be used in your campaign rules. For example, you could define a `zipCode` field for customer sessions, and add a rule to your campaign that only allows certain ZIP codes.  These attributes are shared across all applications in your account, and are never required.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_attribute_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param NewAttribute body: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Attribute, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_attribute" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `create_attribute`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/attributes', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Attribute',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_campaign(self, application_id, body, **kwargs):  # noqa: E501
        """Create a Campaign  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_campaign(application_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param NewCampaign body: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Campaign
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_campaign_with_http_info(application_id, body, **kwargs)  # noqa: E501

    def create_campaign_with_http_info(self, application_id, body, **kwargs):  # noqa: E501
        """Create a Campaign  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_campaign_with_http_info(application_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param NewCampaign body: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Campaign, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_campaign" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `create_campaign`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `create_campaign`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Campaign',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_coupons(self, application_id, campaign_id, body, **kwargs):  # noqa: E501
        """Create Coupons  # noqa: E501

        Create coupons according to some pattern. Up to 20.000 coupons can be created without a unique prefix. When a unique prefix is provided, up to 200.000 coupons can be created.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_coupons(application_id, campaign_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param NewCoupons body: (required)
        :param str silent: If set to 'yes', response will be an empty 204, otherwise a list of the coupons generated (to to 1000).
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_coupons_with_http_info(application_id, campaign_id, body, **kwargs)  # noqa: E501

    def create_coupons_with_http_info(self, application_id, campaign_id, body, **kwargs):  # noqa: E501
        """Create Coupons  # noqa: E501

        Create coupons according to some pattern. Up to 20.000 coupons can be created without a unique prefix. When a unique prefix is provided, up to 200.000 coupons can be created.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_coupons_with_http_info(application_id, campaign_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param NewCoupons body: (required)
        :param str silent: If set to 'yes', response will be an empty 204, otherwise a list of the coupons generated (to to 1000).
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse2001, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'campaign_id', 'body', 'silent']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_coupons" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `create_coupons`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if self.api_client.client_side_validation and ('campaign_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['campaign_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `campaign_id` when calling `create_coupons`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `create_coupons`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501
        if 'campaign_id' in local_var_params:
            path_params['campaignId'] = local_var_params['campaign_id']  # noqa: E501

        query_params = []
        if 'silent' in local_var_params and local_var_params['silent'] is not None:  # noqa: E501
            query_params.append(('silent', local_var_params['silent']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2001',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_password_recovery_email(self, body, **kwargs):  # noqa: E501
        """Request a password reset  # noqa: E501

        Sends an email with a password recovery link to the email of an existing account.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_password_recovery_email(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param NewPasswordEmail body: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: NewPasswordEmail
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_password_recovery_email_with_http_info(body, **kwargs)  # noqa: E501

    def create_password_recovery_email_with_http_info(self, body, **kwargs):  # noqa: E501
        """Request a password reset  # noqa: E501

        Sends an email with a password recovery link to the email of an existing account.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_password_recovery_email_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param NewPasswordEmail body: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(NewPasswordEmail, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_password_recovery_email" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `create_password_recovery_email`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/password_recovery_emails', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NewPasswordEmail',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_ruleset(self, application_id, campaign_id, body, **kwargs):  # noqa: E501
        """Create a Ruleset  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_ruleset(application_id, campaign_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param NewRuleset body: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Ruleset
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_ruleset_with_http_info(application_id, campaign_id, body, **kwargs)  # noqa: E501

    def create_ruleset_with_http_info(self, application_id, campaign_id, body, **kwargs):  # noqa: E501
        """Create a Ruleset  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_ruleset_with_http_info(application_id, campaign_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param NewRuleset body: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Ruleset, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'campaign_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_ruleset" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `create_ruleset`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if self.api_client.client_side_validation and ('campaign_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['campaign_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `campaign_id` when calling `create_ruleset`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `create_ruleset`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501
        if 'campaign_id' in local_var_params:
            path_params['campaignId'] = local_var_params['campaign_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/rulesets', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Ruleset',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_session(self, body, **kwargs):  # noqa: E501
        """Create a Session  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_session(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param LoginParams body: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Session
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.create_session_with_http_info(body, **kwargs)  # noqa: E501

    def create_session_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create a Session  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_session_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param LoginParams body: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Session, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_session" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `create_session`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/sessions', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Session',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_campaign(self, application_id, campaign_id, **kwargs):  # noqa: E501
        """Delete a Campaign  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_campaign(application_id, campaign_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_campaign_with_http_info(application_id, campaign_id, **kwargs)  # noqa: E501

    def delete_campaign_with_http_info(self, application_id, campaign_id, **kwargs):  # noqa: E501
        """Delete a Campaign  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_campaign_with_http_info(application_id, campaign_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'campaign_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_campaign" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `delete_campaign`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if self.api_client.client_side_validation and ('campaign_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['campaign_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `campaign_id` when calling `delete_campaign`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501
        if 'campaign_id' in local_var_params:
            path_params['campaignId'] = local_var_params['campaign_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_coupon(self, application_id, campaign_id, coupon_id, **kwargs):  # noqa: E501
        """Delete one Coupon  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_coupon(application_id, campaign_id, coupon_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param str coupon_id: The ID of the coupon code to delete (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_coupon_with_http_info(application_id, campaign_id, coupon_id, **kwargs)  # noqa: E501

    def delete_coupon_with_http_info(self, application_id, campaign_id, coupon_id, **kwargs):  # noqa: E501
        """Delete one Coupon  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_coupon_with_http_info(application_id, campaign_id, coupon_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param str coupon_id: The ID of the coupon code to delete (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'campaign_id', 'coupon_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_coupon" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `delete_coupon`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if self.api_client.client_side_validation and ('campaign_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['campaign_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `campaign_id` when calling `delete_coupon`")  # noqa: E501
        # verify the required parameter 'coupon_id' is set
        if self.api_client.client_side_validation and ('coupon_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['coupon_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `coupon_id` when calling `delete_coupon`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501
        if 'campaign_id' in local_var_params:
            path_params['campaignId'] = local_var_params['campaign_id']  # noqa: E501
        if 'coupon_id' in local_var_params:
            path_params['couponId'] = local_var_params['coupon_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons/{couponId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_coupons(self, application_id, campaign_id, **kwargs):  # noqa: E501
        """Delete Coupons  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_coupons(application_id, campaign_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime starts_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime starts_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime expires_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime expires_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str batch_id: Filter results by batches of coupons
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_coupons_with_http_info(application_id, campaign_id, **kwargs)  # noqa: E501

    def delete_coupons_with_http_info(self, application_id, campaign_id, **kwargs):  # noqa: E501
        """Delete Coupons  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_coupons_with_http_info(application_id, campaign_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime starts_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime starts_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime expires_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime expires_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str batch_id: Filter results by batches of coupons
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'campaign_id', 'value', 'created_before', 'created_after', 'starts_after', 'starts_before', 'expires_after', 'expires_before', 'valid', 'batch_id', 'usable', 'referral_id', 'recipient_integration_id', 'exact_match']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_coupons" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `delete_coupons`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if self.api_client.client_side_validation and ('campaign_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['campaign_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `campaign_id` when calling `delete_coupons`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501
        if 'campaign_id' in local_var_params:
            path_params['campaignId'] = local_var_params['campaign_id']  # noqa: E501

        query_params = []
        if 'value' in local_var_params and local_var_params['value'] is not None:  # noqa: E501
            query_params.append(('value', local_var_params['value']))  # noqa: E501
        if 'created_before' in local_var_params and local_var_params['created_before'] is not None:  # noqa: E501
            query_params.append(('createdBefore', local_var_params['created_before']))  # noqa: E501
        if 'created_after' in local_var_params and local_var_params['created_after'] is not None:  # noqa: E501
            query_params.append(('createdAfter', local_var_params['created_after']))  # noqa: E501
        if 'starts_after' in local_var_params and local_var_params['starts_after'] is not None:  # noqa: E501
            query_params.append(('startsAfter', local_var_params['starts_after']))  # noqa: E501
        if 'starts_before' in local_var_params and local_var_params['starts_before'] is not None:  # noqa: E501
            query_params.append(('startsBefore', local_var_params['starts_before']))  # noqa: E501
        if 'expires_after' in local_var_params and local_var_params['expires_after'] is not None:  # noqa: E501
            query_params.append(('expiresAfter', local_var_params['expires_after']))  # noqa: E501
        if 'expires_before' in local_var_params and local_var_params['expires_before'] is not None:  # noqa: E501
            query_params.append(('expiresBefore', local_var_params['expires_before']))  # noqa: E501
        if 'valid' in local_var_params and local_var_params['valid'] is not None:  # noqa: E501
            query_params.append(('valid', local_var_params['valid']))  # noqa: E501
        if 'batch_id' in local_var_params and local_var_params['batch_id'] is not None:  # noqa: E501
            query_params.append(('batchId', local_var_params['batch_id']))  # noqa: E501
        if 'usable' in local_var_params and local_var_params['usable'] is not None:  # noqa: E501
            query_params.append(('usable', local_var_params['usable']))  # noqa: E501
        if 'referral_id' in local_var_params and local_var_params['referral_id'] is not None:  # noqa: E501
            query_params.append(('referralId', local_var_params['referral_id']))  # noqa: E501
        if 'recipient_integration_id' in local_var_params and local_var_params['recipient_integration_id'] is not None:  # noqa: E501
            query_params.append(('recipientIntegrationId', local_var_params['recipient_integration_id']))  # noqa: E501
        if 'exact_match' in local_var_params and local_var_params['exact_match'] is not None:  # noqa: E501
            query_params.append(('exactMatch', local_var_params['exact_match']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_referral(self, application_id, campaign_id, referral_id, **kwargs):  # noqa: E501
        """Delete one Referral  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_referral(application_id, campaign_id, referral_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param str referral_id: The ID of the referral code to delete (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_referral_with_http_info(application_id, campaign_id, referral_id, **kwargs)  # noqa: E501

    def delete_referral_with_http_info(self, application_id, campaign_id, referral_id, **kwargs):  # noqa: E501
        """Delete one Referral  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_referral_with_http_info(application_id, campaign_id, referral_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param str referral_id: The ID of the referral code to delete (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'campaign_id', 'referral_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_referral" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `delete_referral`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if self.api_client.client_side_validation and ('campaign_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['campaign_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `campaign_id` when calling `delete_referral`")  # noqa: E501
        # verify the required parameter 'referral_id' is set
        if self.api_client.client_side_validation and ('referral_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['referral_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `referral_id` when calling `delete_referral`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501
        if 'campaign_id' in local_var_params:
            path_params['campaignId'] = local_var_params['campaign_id']  # noqa: E501
        if 'referral_id' in local_var_params:
            path_params['referralId'] = local_var_params['referral_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/referrals/{referralId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_ruleset(self, application_id, campaign_id, ruleset_id, **kwargs):  # noqa: E501
        """Delete a Ruleset  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ruleset(application_id, campaign_id, ruleset_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param int ruleset_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.delete_ruleset_with_http_info(application_id, campaign_id, ruleset_id, **kwargs)  # noqa: E501

    def delete_ruleset_with_http_info(self, application_id, campaign_id, ruleset_id, **kwargs):  # noqa: E501
        """Delete a Ruleset  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_ruleset_with_http_info(application_id, campaign_id, ruleset_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param int ruleset_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'campaign_id', 'ruleset_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_ruleset" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `delete_ruleset`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if self.api_client.client_side_validation and ('campaign_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['campaign_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `campaign_id` when calling `delete_ruleset`")  # noqa: E501
        # verify the required parameter 'ruleset_id' is set
        if self.api_client.client_side_validation and ('ruleset_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['ruleset_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `ruleset_id` when calling `delete_ruleset`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501
        if 'campaign_id' in local_var_params:
            path_params['campaignId'] = local_var_params['campaign_id']  # noqa: E501
        if 'ruleset_id' in local_var_params:
            path_params['rulesetId'] = local_var_params['ruleset_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/rulesets/{rulesetId}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_access_logs(self, application_id, range_start, range_end, **kwargs):  # noqa: E501
        """Get access logs for application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_logs(application_id, range_start, range_end, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param datetime range_start: Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
        :param datetime range_end: Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
        :param str path: Only return results where the request path matches the given regular expression.
        :param str method: Only return results where the request method matches the given regular expression.
        :param str status: Filter results by HTTP status codes.
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse2009
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_access_logs_with_http_info(application_id, range_start, range_end, **kwargs)  # noqa: E501

    def get_access_logs_with_http_info(self, application_id, range_start, range_end, **kwargs):  # noqa: E501
        """Get access logs for application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_logs_with_http_info(application_id, range_start, range_end, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param datetime range_start: Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
        :param datetime range_end: Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
        :param str path: Only return results where the request path matches the given regular expression.
        :param str method: Only return results where the request method matches the given regular expression.
        :param str status: Filter results by HTTP status codes.
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse2009, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'range_start', 'range_end', 'path', 'method', 'status', 'page_size', 'skip', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_access_logs" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `get_access_logs`")  # noqa: E501
        # verify the required parameter 'range_start' is set
        if self.api_client.client_side_validation and ('range_start' not in local_var_params or  # noqa: E501
                                                        local_var_params['range_start'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `range_start` when calling `get_access_logs`")  # noqa: E501
        # verify the required parameter 'range_end' is set
        if self.api_client.client_side_validation and ('range_end' not in local_var_params or  # noqa: E501
                                                        local_var_params['range_end'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `range_end` when calling `get_access_logs`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'path' in local_var_params and local_var_params['path'] is not None:  # noqa: E501
            query_params.append(('path', local_var_params['path']))  # noqa: E501
        if 'method' in local_var_params and local_var_params['method'] is not None:  # noqa: E501
            query_params.append(('method', local_var_params['method']))  # noqa: E501
        if 'status' in local_var_params and local_var_params['status'] is not None:  # noqa: E501
            query_params.append(('status', local_var_params['status']))  # noqa: E501
        if 'range_start' in local_var_params and local_var_params['range_start'] is not None:  # noqa: E501
            query_params.append(('rangeStart', local_var_params['range_start']))  # noqa: E501
        if 'range_end' in local_var_params and local_var_params['range_end'] is not None:  # noqa: E501
            query_params.append(('rangeEnd', local_var_params['range_end']))  # noqa: E501
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/access_logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2009',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_access_logs_without_total_count(self, application_id, range_start, range_end, **kwargs):  # noqa: E501
        """Get access logs for application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_logs_without_total_count(application_id, range_start, range_end, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param datetime range_start: Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
        :param datetime range_end: Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
        :param str path: Only return results where the request path matches the given regular expression.
        :param str method: Only return results where the request method matches the given regular expression.
        :param str status: Filter results by HTTP status codes.
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20010
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_access_logs_without_total_count_with_http_info(application_id, range_start, range_end, **kwargs)  # noqa: E501

    def get_access_logs_without_total_count_with_http_info(self, application_id, range_start, range_end, **kwargs):  # noqa: E501
        """Get access logs for application  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_access_logs_without_total_count_with_http_info(application_id, range_start, range_end, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param datetime range_start: Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
        :param datetime range_end: Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
        :param str path: Only return results where the request path matches the given regular expression.
        :param str method: Only return results where the request method matches the given regular expression.
        :param str status: Filter results by HTTP status codes.
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20010, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'range_start', 'range_end', 'path', 'method', 'status', 'page_size', 'skip', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_access_logs_without_total_count" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `get_access_logs_without_total_count`")  # noqa: E501
        # verify the required parameter 'range_start' is set
        if self.api_client.client_side_validation and ('range_start' not in local_var_params or  # noqa: E501
                                                        local_var_params['range_start'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `range_start` when calling `get_access_logs_without_total_count`")  # noqa: E501
        # verify the required parameter 'range_end' is set
        if self.api_client.client_side_validation and ('range_end' not in local_var_params or  # noqa: E501
                                                        local_var_params['range_end'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `range_end` when calling `get_access_logs_without_total_count`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'path' in local_var_params and local_var_params['path'] is not None:  # noqa: E501
            query_params.append(('path', local_var_params['path']))  # noqa: E501
        if 'method' in local_var_params and local_var_params['method'] is not None:  # noqa: E501
            query_params.append(('method', local_var_params['method']))  # noqa: E501
        if 'status' in local_var_params and local_var_params['status'] is not None:  # noqa: E501
            query_params.append(('status', local_var_params['status']))  # noqa: E501
        if 'range_start' in local_var_params and local_var_params['range_start'] is not None:  # noqa: E501
            query_params.append(('rangeStart', local_var_params['range_start']))  # noqa: E501
        if 'range_end' in local_var_params and local_var_params['range_end'] is not None:  # noqa: E501
            query_params.append(('rangeEnd', local_var_params['range_end']))  # noqa: E501
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/access_logs/no_total', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20010',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_account(self, account_id, **kwargs):  # noqa: E501
        """Get Account Details  # noqa: E501

        Return the details of your companies Talon.One account.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int account_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Account
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_account_with_http_info(account_id, **kwargs)  # noqa: E501

    def get_account_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """Get Account Details  # noqa: E501

        Return the details of your companies Talon.One account.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int account_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Account, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'account_id' is set
        if self.api_client.client_side_validation and ('account_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['account_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `account_id` when calling `get_account`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in local_var_params:
            path_params['accountId'] = local_var_params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{accountId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Account',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_account_analytics(self, account_id, **kwargs):  # noqa: E501
        """Get Account Analytics  # noqa: E501

        Return the analytics of your companies Talon.One account.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_analytics(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int account_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AccountAnalytics
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_account_analytics_with_http_info(account_id, **kwargs)  # noqa: E501

    def get_account_analytics_with_http_info(self, account_id, **kwargs):  # noqa: E501
        """Get Account Analytics  # noqa: E501

        Return the analytics of your companies Talon.One account.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_account_analytics_with_http_info(account_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int account_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AccountAnalytics, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['account_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_account_analytics" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'account_id' is set
        if self.api_client.client_side_validation and ('account_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['account_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `account_id` when calling `get_account_analytics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'account_id' in local_var_params:
            path_params['accountId'] = local_var_params['account_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/accounts/{accountId}/analytics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccountAnalytics',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_additional_cost(self, additional_cost_id, **kwargs):  # noqa: E501
        """Get an additional cost  # noqa: E501

        Returns additional cost for the account by its id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_additional_cost(additional_cost_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int additional_cost_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AccountAdditionalCost
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_additional_cost_with_http_info(additional_cost_id, **kwargs)  # noqa: E501

    def get_additional_cost_with_http_info(self, additional_cost_id, **kwargs):  # noqa: E501
        """Get an additional cost  # noqa: E501

        Returns additional cost for the account by its id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_additional_cost_with_http_info(additional_cost_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int additional_cost_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AccountAdditionalCost, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['additional_cost_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_additional_cost" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'additional_cost_id' is set
        if self.api_client.client_side_validation and ('additional_cost_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['additional_cost_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `additional_cost_id` when calling `get_additional_cost`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'additional_cost_id' in local_var_params:
            path_params['additionalCostId'] = local_var_params['additional_cost_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/additional_costs/{additionalCostId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccountAdditionalCost',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_additional_costs(self, **kwargs):  # noqa: E501
        """List additional costs  # noqa: E501

        Returns all the defined additional costs for the account.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_additional_costs(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20021
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_additional_costs_with_http_info(**kwargs)  # noqa: E501

    def get_additional_costs_with_http_info(self, **kwargs):  # noqa: E501
        """List additional costs  # noqa: E501

        Returns all the defined additional costs for the account.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_additional_costs_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20021, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['page_size', 'skip', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_additional_costs" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/additional_costs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20021',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_access_logs(self, range_start, range_end, **kwargs):  # noqa: E501
        """Get all access logs  # noqa: E501

        Fetches the access logs for the entire account. Sensitive requests (logins) are _always_ filtered from the logs.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_access_logs(range_start, range_end, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime range_start: Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
        :param datetime range_end: Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
        :param str path: Only return results where the request path matches the given regular expression.
        :param str method: Only return results where the request method matches the given regular expression.
        :param str status: Filter results by HTTP status codes.
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse2009
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_all_access_logs_with_http_info(range_start, range_end, **kwargs)  # noqa: E501

    def get_all_access_logs_with_http_info(self, range_start, range_end, **kwargs):  # noqa: E501
        """Get all access logs  # noqa: E501

        Fetches the access logs for the entire account. Sensitive requests (logins) are _always_ filtered from the logs.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_access_logs_with_http_info(range_start, range_end, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime range_start: Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
        :param datetime range_end: Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
        :param str path: Only return results where the request path matches the given regular expression.
        :param str method: Only return results where the request method matches the given regular expression.
        :param str status: Filter results by HTTP status codes.
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse2009, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['range_start', 'range_end', 'path', 'method', 'status', 'page_size', 'skip', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_access_logs" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'range_start' is set
        if self.api_client.client_side_validation and ('range_start' not in local_var_params or  # noqa: E501
                                                        local_var_params['range_start'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `range_start` when calling `get_all_access_logs`")  # noqa: E501
        # verify the required parameter 'range_end' is set
        if self.api_client.client_side_validation and ('range_end' not in local_var_params or  # noqa: E501
                                                        local_var_params['range_end'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `range_end` when calling `get_all_access_logs`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'range_start' in local_var_params and local_var_params['range_start'] is not None:  # noqa: E501
            query_params.append(('rangeStart', local_var_params['range_start']))  # noqa: E501
        if 'range_end' in local_var_params and local_var_params['range_end'] is not None:  # noqa: E501
            query_params.append(('rangeEnd', local_var_params['range_end']))  # noqa: E501
        if 'path' in local_var_params and local_var_params['path'] is not None:  # noqa: E501
            query_params.append(('path', local_var_params['path']))  # noqa: E501
        if 'method' in local_var_params and local_var_params['method'] is not None:  # noqa: E501
            query_params.append(('method', local_var_params['method']))  # noqa: E501
        if 'status' in local_var_params and local_var_params['status'] is not None:  # noqa: E501
            query_params.append(('status', local_var_params['status']))  # noqa: E501
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/access_logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2009',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_all_roles(self, **kwargs):  # noqa: E501
        """Get all roles.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_roles(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20030
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_all_roles_with_http_info(**kwargs)  # noqa: E501

    def get_all_roles_with_http_info(self, **kwargs):  # noqa: E501
        """Get all roles.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_all_roles_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20030, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_all_roles" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/roles', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20030',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_application(self, application_id, **kwargs):  # noqa: E501
        """Get Application  # noqa: E501

        Get the application specified by the ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Application
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_application_with_http_info(application_id, **kwargs)  # noqa: E501

    def get_application_with_http_info(self, application_id, **kwargs):  # noqa: E501
        """Get Application  # noqa: E501

        Get the application specified by the ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_with_http_info(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Application, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_application" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `get_application`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Application',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_application_api_health(self, application_id, **kwargs):  # noqa: E501
        """Get report of health of application API  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_api_health(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ApplicationApiHealth
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_application_api_health_with_http_info(application_id, **kwargs)  # noqa: E501

    def get_application_api_health_with_http_info(self, application_id, **kwargs):  # noqa: E501
        """Get report of health of application API  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_api_health_with_http_info(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ApplicationApiHealth, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_application_api_health" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `get_application_api_health`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/health_report', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApplicationApiHealth',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_application_customer(self, application_id, customer_id, **kwargs):  # noqa: E501
        """Get Application Customer  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_customer(application_id, customer_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int customer_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ApplicationCustomer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_application_customer_with_http_info(application_id, customer_id, **kwargs)  # noqa: E501

    def get_application_customer_with_http_info(self, application_id, customer_id, **kwargs):  # noqa: E501
        """Get Application Customer  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_customer_with_http_info(application_id, customer_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int customer_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ApplicationCustomer, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'customer_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_application_customer" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `get_application_customer`")  # noqa: E501
        # verify the required parameter 'customer_id' is set
        if self.api_client.client_side_validation and ('customer_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['customer_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `customer_id` when calling `get_application_customer`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501
        if 'customer_id' in local_var_params:
            path_params['customerId'] = local_var_params['customer_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/customers/{customerId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApplicationCustomer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_application_customers(self, application_id, **kwargs):  # noqa: E501
        """List Application Customers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_customers(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20012
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_application_customers_with_http_info(application_id, **kwargs)  # noqa: E501

    def get_application_customers_with_http_info(self, application_id, **kwargs):  # noqa: E501
        """List Application Customers  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_customers_with_http_info(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20012, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_application_customers" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `get_application_customers`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/customers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20012',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_application_customers_by_attributes(self, body, **kwargs):  # noqa: E501
        """Get a list of the customer profiles that match the given attributes  # noqa: E501

        Gets a list of all the customer profiles for the account that exactly match a set of attributes.  The match is successful if all the attributes of the request are found in a profile, even if the profile has more attributes that are not present on the request.  [Customer Profile]: https://help.talon.one/hc/en-us/articles/360005130739-Data-Model#CustomerProfile   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_customers_by_attributes(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ApplicationCustomerSearch body: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20013
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_application_customers_by_attributes_with_http_info(body, **kwargs)  # noqa: E501

    def get_application_customers_by_attributes_with_http_info(self, body, **kwargs):  # noqa: E501
        """Get a list of the customer profiles that match the given attributes  # noqa: E501

        Gets a list of all the customer profiles for the account that exactly match a set of attributes.  The match is successful if all the attributes of the request are found in a profile, even if the profile has more attributes that are not present on the request.  [Customer Profile]: https://help.talon.one/hc/en-us/articles/360005130739-Data-Model#CustomerProfile   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_customers_by_attributes_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ApplicationCustomerSearch body: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20013, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_application_customers_by_attributes" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `get_application_customers_by_attributes`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['integration_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/application_customer_search', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20013',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_application_event_types(self, application_id, **kwargs):  # noqa: E501
        """List Applications Event Types  # noqa: E501

        Get all of the distinct values of the Event `type` property for events recorded in the application.  See also: [Track an event](/integration-api/reference/#trackEvent)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_event_types(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20019
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_application_event_types_with_http_info(application_id, **kwargs)  # noqa: E501

    def get_application_event_types_with_http_info(self, application_id, **kwargs):  # noqa: E501
        """List Applications Event Types  # noqa: E501

        Get all of the distinct values of the Event `type` property for events recorded in the application.  See also: [Track an event](/integration-api/reference/#trackEvent)   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_event_types_with_http_info(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20019, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'page_size', 'skip', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_application_event_types" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `get_application_event_types`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/event_types', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20019',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_application_events(self, application_id, **kwargs):  # noqa: E501
        """List Applications Events  # noqa: E501

        Lists all events recorded for an application.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_events(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str type: Comma-separated list of types by which to filter events. Must be exact match(es).
        :param datetime created_before: Only return events created before this date
        :param datetime created_after: Only return events created after this date
        :param str session: Session integration ID filter for events. Must be exact match.
        :param str profile: Profile integration ID filter for events. Must be exact match.
        :param str customer_name: Customer name filter for events. Will match substrings case-insensitively.
        :param str customer_email: Customer e-mail address filter for events. Will match substrings case-insensitively.
        :param str coupon_code: Coupon code
        :param str referral_code: Referral code
        :param str rule_query: Rule name filter for events
        :param str campaign_query: Campaign name filter for events
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20017
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_application_events_with_http_info(application_id, **kwargs)  # noqa: E501

    def get_application_events_with_http_info(self, application_id, **kwargs):  # noqa: E501
        """List Applications Events  # noqa: E501

        Lists all events recorded for an application.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_events_with_http_info(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str type: Comma-separated list of types by which to filter events. Must be exact match(es).
        :param datetime created_before: Only return events created before this date
        :param datetime created_after: Only return events created after this date
        :param str session: Session integration ID filter for events. Must be exact match.
        :param str profile: Profile integration ID filter for events. Must be exact match.
        :param str customer_name: Customer name filter for events. Will match substrings case-insensitively.
        :param str customer_email: Customer e-mail address filter for events. Will match substrings case-insensitively.
        :param str coupon_code: Coupon code
        :param str referral_code: Referral code
        :param str rule_query: Rule name filter for events
        :param str campaign_query: Campaign name filter for events
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20017, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'page_size', 'skip', 'sort', 'type', 'created_before', 'created_after', 'session', 'profile', 'customer_name', 'customer_email', 'coupon_code', 'referral_code', 'rule_query', 'campaign_query']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_application_events" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `get_application_events`")  # noqa: E501

        if self.api_client.client_side_validation and ('customer_name' in local_var_params and  # noqa: E501
                                                        len(local_var_params['customer_name']) < 2):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `customer_name` when calling `get_application_events`, length must be greater than or equal to `2`")  # noqa: E501
        if self.api_client.client_side_validation and ('customer_email' in local_var_params and  # noqa: E501
                                                        len(local_var_params['customer_email']) < 2):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `customer_email` when calling `get_application_events`, length must be greater than or equal to `2`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
        if 'created_before' in local_var_params and local_var_params['created_before'] is not None:  # noqa: E501
            query_params.append(('createdBefore', local_var_params['created_before']))  # noqa: E501
        if 'created_after' in local_var_params and local_var_params['created_after'] is not None:  # noqa: E501
            query_params.append(('createdAfter', local_var_params['created_after']))  # noqa: E501
        if 'session' in local_var_params and local_var_params['session'] is not None:  # noqa: E501
            query_params.append(('session', local_var_params['session']))  # noqa: E501
        if 'profile' in local_var_params and local_var_params['profile'] is not None:  # noqa: E501
            query_params.append(('profile', local_var_params['profile']))  # noqa: E501
        if 'customer_name' in local_var_params and local_var_params['customer_name'] is not None:  # noqa: E501
            query_params.append(('customerName', local_var_params['customer_name']))  # noqa: E501
        if 'customer_email' in local_var_params and local_var_params['customer_email'] is not None:  # noqa: E501
            query_params.append(('customerEmail', local_var_params['customer_email']))  # noqa: E501
        if 'coupon_code' in local_var_params and local_var_params['coupon_code'] is not None:  # noqa: E501
            query_params.append(('couponCode', local_var_params['coupon_code']))  # noqa: E501
        if 'referral_code' in local_var_params and local_var_params['referral_code'] is not None:  # noqa: E501
            query_params.append(('referralCode', local_var_params['referral_code']))  # noqa: E501
        if 'rule_query' in local_var_params and local_var_params['rule_query'] is not None:  # noqa: E501
            query_params.append(('ruleQuery', local_var_params['rule_query']))  # noqa: E501
        if 'campaign_query' in local_var_params and local_var_params['campaign_query'] is not None:  # noqa: E501
            query_params.append(('campaignQuery', local_var_params['campaign_query']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/events', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20017',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_application_events_without_total_count(self, application_id, **kwargs):  # noqa: E501
        """List Applications Events  # noqa: E501

        Lists all events recorded for an application. Instead of having the total number of results in the response, this endpoint only if there are more results.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_events_without_total_count(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str type: Comma-separated list of types by which to filter events. Must be exact match(es).
        :param datetime created_before: Only return events created before this date
        :param datetime created_after: Only return events created after this date
        :param str session: Session integration ID filter for events. Must be exact match.
        :param str profile: Profile integration ID filter for events. Must be exact match.
        :param str customer_name: Customer name filter for events. Will match substrings case-insensitively.
        :param str customer_email: Customer e-mail address filter for events. Will match substrings case-insensitively.
        :param str coupon_code: Coupon code
        :param str referral_code: Referral code
        :param str rule_query: Rule name filter for events
        :param str campaign_query: Campaign name filter for events
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20018
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_application_events_without_total_count_with_http_info(application_id, **kwargs)  # noqa: E501

    def get_application_events_without_total_count_with_http_info(self, application_id, **kwargs):  # noqa: E501
        """List Applications Events  # noqa: E501

        Lists all events recorded for an application. Instead of having the total number of results in the response, this endpoint only if there are more results.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_events_without_total_count_with_http_info(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str type: Comma-separated list of types by which to filter events. Must be exact match(es).
        :param datetime created_before: Only return events created before this date
        :param datetime created_after: Only return events created after this date
        :param str session: Session integration ID filter for events. Must be exact match.
        :param str profile: Profile integration ID filter for events. Must be exact match.
        :param str customer_name: Customer name filter for events. Will match substrings case-insensitively.
        :param str customer_email: Customer e-mail address filter for events. Will match substrings case-insensitively.
        :param str coupon_code: Coupon code
        :param str referral_code: Referral code
        :param str rule_query: Rule name filter for events
        :param str campaign_query: Campaign name filter for events
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20018, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'page_size', 'skip', 'sort', 'type', 'created_before', 'created_after', 'session', 'profile', 'customer_name', 'customer_email', 'coupon_code', 'referral_code', 'rule_query', 'campaign_query']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_application_events_without_total_count" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `get_application_events_without_total_count`")  # noqa: E501

        if self.api_client.client_side_validation and ('customer_name' in local_var_params and  # noqa: E501
                                                        len(local_var_params['customer_name']) < 2):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `customer_name` when calling `get_application_events_without_total_count`, length must be greater than or equal to `2`")  # noqa: E501
        if self.api_client.client_side_validation and ('customer_email' in local_var_params and  # noqa: E501
                                                        len(local_var_params['customer_email']) < 2):  # noqa: E501
            raise ApiValueError("Invalid value for parameter `customer_email` when calling `get_application_events_without_total_count`, length must be greater than or equal to `2`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'type' in local_var_params and local_var_params['type'] is not None:  # noqa: E501
            query_params.append(('type', local_var_params['type']))  # noqa: E501
        if 'created_before' in local_var_params and local_var_params['created_before'] is not None:  # noqa: E501
            query_params.append(('createdBefore', local_var_params['created_before']))  # noqa: E501
        if 'created_after' in local_var_params and local_var_params['created_after'] is not None:  # noqa: E501
            query_params.append(('createdAfter', local_var_params['created_after']))  # noqa: E501
        if 'session' in local_var_params and local_var_params['session'] is not None:  # noqa: E501
            query_params.append(('session', local_var_params['session']))  # noqa: E501
        if 'profile' in local_var_params and local_var_params['profile'] is not None:  # noqa: E501
            query_params.append(('profile', local_var_params['profile']))  # noqa: E501
        if 'customer_name' in local_var_params and local_var_params['customer_name'] is not None:  # noqa: E501
            query_params.append(('customerName', local_var_params['customer_name']))  # noqa: E501
        if 'customer_email' in local_var_params and local_var_params['customer_email'] is not None:  # noqa: E501
            query_params.append(('customerEmail', local_var_params['customer_email']))  # noqa: E501
        if 'coupon_code' in local_var_params and local_var_params['coupon_code'] is not None:  # noqa: E501
            query_params.append(('couponCode', local_var_params['coupon_code']))  # noqa: E501
        if 'referral_code' in local_var_params and local_var_params['referral_code'] is not None:  # noqa: E501
            query_params.append(('referralCode', local_var_params['referral_code']))  # noqa: E501
        if 'rule_query' in local_var_params and local_var_params['rule_query'] is not None:  # noqa: E501
            query_params.append(('ruleQuery', local_var_params['rule_query']))  # noqa: E501
        if 'campaign_query' in local_var_params and local_var_params['campaign_query'] is not None:  # noqa: E501
            query_params.append(('campaignQuery', local_var_params['campaign_query']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/events/no_total', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20018',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_application_session(self, application_id, session_id, **kwargs):  # noqa: E501
        """Get Application Session  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_session(application_id, session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int session_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ApplicationSession
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_application_session_with_http_info(application_id, session_id, **kwargs)  # noqa: E501

    def get_application_session_with_http_info(self, application_id, session_id, **kwargs):  # noqa: E501
        """Get Application Session  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_session_with_http_info(application_id, session_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int session_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ApplicationSession, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'session_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_application_session" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `get_application_session`")  # noqa: E501
        # verify the required parameter 'session_id' is set
        if self.api_client.client_side_validation and ('session_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['session_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `session_id` when calling `get_application_session`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501
        if 'session_id' in local_var_params:
            path_params['sessionId'] = local_var_params['session_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/sessions/{sessionId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApplicationSession',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_application_sessions(self, application_id, **kwargs):  # noqa: E501
        """List Application Sessions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_sessions(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str profile: Profile integration ID filter for sessions. Must be exact match.
        :param str state: Filter by sessions with this state. Must be exact match.
        :param str coupon: Filter by sessions with this coupon. Must be exact match.
        :param str referral: Filter by sessions with this referral. Must be exact match.
        :param str integration_id: Filter by sessions with this integrationId. Must be exact match.
        :param str customer_id: Filter by integration ID of the customer for the session
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20016
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_application_sessions_with_http_info(application_id, **kwargs)  # noqa: E501

    def get_application_sessions_with_http_info(self, application_id, **kwargs):  # noqa: E501
        """List Application Sessions  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_application_sessions_with_http_info(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str profile: Profile integration ID filter for sessions. Must be exact match.
        :param str state: Filter by sessions with this state. Must be exact match.
        :param str coupon: Filter by sessions with this coupon. Must be exact match.
        :param str referral: Filter by sessions with this referral. Must be exact match.
        :param str integration_id: Filter by sessions with this integrationId. Must be exact match.
        :param str customer_id: Filter by integration ID of the customer for the session
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20016, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'page_size', 'skip', 'sort', 'profile', 'state', 'coupon', 'referral', 'integration_id', 'customer_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_application_sessions" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `get_application_sessions`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'profile' in local_var_params and local_var_params['profile'] is not None:  # noqa: E501
            query_params.append(('profile', local_var_params['profile']))  # noqa: E501
        if 'state' in local_var_params and local_var_params['state'] is not None:  # noqa: E501
            query_params.append(('state', local_var_params['state']))  # noqa: E501
        if 'coupon' in local_var_params and local_var_params['coupon'] is not None:  # noqa: E501
            query_params.append(('coupon', local_var_params['coupon']))  # noqa: E501
        if 'referral' in local_var_params and local_var_params['referral'] is not None:  # noqa: E501
            query_params.append(('referral', local_var_params['referral']))  # noqa: E501
        if 'integration_id' in local_var_params and local_var_params['integration_id'] is not None:  # noqa: E501
            query_params.append(('integrationId', local_var_params['integration_id']))  # noqa: E501
        if 'customer_id' in local_var_params and local_var_params['customer_id'] is not None:  # noqa: E501
            query_params.append(('customerId', local_var_params['customer_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/sessions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20016',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_applications(self, **kwargs):  # noqa: E501
        """List Applications  # noqa: E501

        List all application in the current account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_applications(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_applications_with_http_info(**kwargs)  # noqa: E501

    def get_applications_with_http_info(self, **kwargs):  # noqa: E501
        """List Applications  # noqa: E501

        List all application in the current account.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_applications_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse2002, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['page_size', 'skip', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_applications" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2002',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_attribute(self, attribute_id, **kwargs):  # noqa: E501
        """Get a custom attribute  # noqa: E501

        Returns custom attribute for the account by its id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_attribute(attribute_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int attribute_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Attribute
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_attribute_with_http_info(attribute_id, **kwargs)  # noqa: E501

    def get_attribute_with_http_info(self, attribute_id, **kwargs):  # noqa: E501
        """Get a custom attribute  # noqa: E501

        Returns custom attribute for the account by its id.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_attribute_with_http_info(attribute_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int attribute_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Attribute, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['attribute_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_attribute" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'attribute_id' is set
        if self.api_client.client_side_validation and ('attribute_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['attribute_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `attribute_id` when calling `get_attribute`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'attribute_id' in local_var_params:
            path_params['attributeId'] = local_var_params['attribute_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/attributes/{attributeId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Attribute',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_attributes(self, **kwargs):  # noqa: E501
        """List custom attributes  # noqa: E501

        Returns all the defined custom attributes for the account.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_attributes(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20020
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_attributes_with_http_info(**kwargs)  # noqa: E501

    def get_attributes_with_http_info(self, **kwargs):  # noqa: E501
        """List custom attributes  # noqa: E501

        Returns all the defined custom attributes for the account.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_attributes_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20020, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['page_size', 'skip', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_attributes" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/attributes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20020',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_campaign(self, application_id, campaign_id, **kwargs):  # noqa: E501
        """Get a Campaign  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_campaign(application_id, campaign_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Campaign
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_campaign_with_http_info(application_id, campaign_id, **kwargs)  # noqa: E501

    def get_campaign_with_http_info(self, application_id, campaign_id, **kwargs):  # noqa: E501
        """Get a Campaign  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_campaign_with_http_info(application_id, campaign_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Campaign, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'campaign_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_campaign" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `get_campaign`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if self.api_client.client_side_validation and ('campaign_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['campaign_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `campaign_id` when calling `get_campaign`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501
        if 'campaign_id' in local_var_params:
            path_params['campaignId'] = local_var_params['campaign_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Campaign',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_campaign_analytics(self, application_id, campaign_id, range_start, range_end, **kwargs):  # noqa: E501
        """Get analytics of campaigns  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_campaign_analytics(application_id, campaign_id, range_start, range_end, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param datetime range_start: Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
        :param datetime range_end: Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
        :param str granularity: The time interval between the results in the returned time-series.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20011
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_campaign_analytics_with_http_info(application_id, campaign_id, range_start, range_end, **kwargs)  # noqa: E501

    def get_campaign_analytics_with_http_info(self, application_id, campaign_id, range_start, range_end, **kwargs):  # noqa: E501
        """Get analytics of campaigns  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_campaign_analytics_with_http_info(application_id, campaign_id, range_start, range_end, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param datetime range_start: Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
        :param datetime range_end: Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
        :param str granularity: The time interval between the results in the returned time-series.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20011, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'campaign_id', 'range_start', 'range_end', 'granularity']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_campaign_analytics" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `get_campaign_analytics`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if self.api_client.client_side_validation and ('campaign_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['campaign_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `campaign_id` when calling `get_campaign_analytics`")  # noqa: E501
        # verify the required parameter 'range_start' is set
        if self.api_client.client_side_validation and ('range_start' not in local_var_params or  # noqa: E501
                                                        local_var_params['range_start'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `range_start` when calling `get_campaign_analytics`")  # noqa: E501
        # verify the required parameter 'range_end' is set
        if self.api_client.client_side_validation and ('range_end' not in local_var_params or  # noqa: E501
                                                        local_var_params['range_end'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `range_end` when calling `get_campaign_analytics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501
        if 'campaign_id' in local_var_params:
            path_params['campaignId'] = local_var_params['campaign_id']  # noqa: E501

        query_params = []
        if 'range_start' in local_var_params and local_var_params['range_start'] is not None:  # noqa: E501
            query_params.append(('rangeStart', local_var_params['range_start']))  # noqa: E501
        if 'range_end' in local_var_params and local_var_params['range_end'] is not None:  # noqa: E501
            query_params.append(('rangeEnd', local_var_params['range_end']))  # noqa: E501
        if 'granularity' in local_var_params and local_var_params['granularity'] is not None:  # noqa: E501
            query_params.append(('granularity', local_var_params['granularity']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/analytics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20011',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_campaign_by_attributes(self, application_id, body, **kwargs):  # noqa: E501
        """Get a list of all campaigns that match the given attributes  # noqa: E501

        Gets a list of all the campaigns that exactly match a set of attributes.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_campaign_by_attributes(application_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param CampaignSearch body: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str campaign_state: Filter results by the state of the campaign.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_campaign_by_attributes_with_http_info(application_id, body, **kwargs)  # noqa: E501

    def get_campaign_by_attributes_with_http_info(self, application_id, body, **kwargs):  # noqa: E501
        """Get a list of all campaigns that match the given attributes  # noqa: E501

        Gets a list of all the campaigns that exactly match a set of attributes.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_campaign_by_attributes_with_http_info(application_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param CampaignSearch body: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str campaign_state: Filter results by the state of the campaign.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse2003, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'body', 'page_size', 'skip', 'sort', 'campaign_state']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_campaign_by_attributes" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `get_campaign_by_attributes`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `get_campaign_by_attributes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'campaign_state' in local_var_params and local_var_params['campaign_state'] is not None:  # noqa: E501
            query_params.append(('campaignState', local_var_params['campaign_state']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns_search', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2003',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_campaign_set(self, application_id, **kwargs):  # noqa: E501
        """List CampaignSet  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_campaign_set(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CampaignSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_campaign_set_with_http_info(application_id, **kwargs)  # noqa: E501

    def get_campaign_set_with_http_info(self, application_id, **kwargs):  # noqa: E501
        """List CampaignSet  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_campaign_set_with_http_info(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CampaignSet, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_campaign_set" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `get_campaign_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaign_set', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CampaignSet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_campaigns(self, application_id, **kwargs):  # noqa: E501
        """List your Campaigns  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_campaigns(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str campaign_state: Filter results by the state of the campaign.
        :param str name: Filter results performing case-insensitive matching against the name of the campaign.
        :param str tags: Filter results performing case-insensitive matching against the tags of the campaign. When used in conjunction with the \"name\" query parameter, a logical OR will be performed to search both tags and name for the provided values 
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the campaign creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the campaign creation timestamp.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_campaigns_with_http_info(application_id, **kwargs)  # noqa: E501

    def get_campaigns_with_http_info(self, application_id, **kwargs):  # noqa: E501
        """List your Campaigns  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_campaigns_with_http_info(application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str campaign_state: Filter results by the state of the campaign.
        :param str name: Filter results performing case-insensitive matching against the name of the campaign.
        :param str tags: Filter results performing case-insensitive matching against the tags of the campaign. When used in conjunction with the \"name\" query parameter, a logical OR will be performed to search both tags and name for the provided values 
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the campaign creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the campaign creation timestamp.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse2003, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'page_size', 'skip', 'sort', 'campaign_state', 'name', 'tags', 'created_before', 'created_after']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_campaigns" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `get_campaigns`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'campaign_state' in local_var_params and local_var_params['campaign_state'] is not None:  # noqa: E501
            query_params.append(('campaignState', local_var_params['campaign_state']))  # noqa: E501
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'tags' in local_var_params and local_var_params['tags'] is not None:  # noqa: E501
            query_params.append(('tags', local_var_params['tags']))  # noqa: E501
        if 'created_before' in local_var_params and local_var_params['created_before'] is not None:  # noqa: E501
            query_params.append(('createdBefore', local_var_params['created_before']))  # noqa: E501
        if 'created_after' in local_var_params and local_var_params['created_after'] is not None:  # noqa: E501
            query_params.append(('createdAfter', local_var_params['created_after']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2003',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_changes(self, **kwargs):  # noqa: E501
        """Get audit log for an account  # noqa: E501

        Get list of changes caused by API calls for an account. Only accessible for admins.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_changes(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param int application_id:
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the change creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the change creation timestamp.
        :param bool with_total_result_size: When this flag is set, the result will include the total size of the result, across all pages. This might decrease performance on large data sets. With this flag set to true, hasMore will be be true whenever there is a next page. totalResultSize will always be zero. With this flag set to false, hasMore will always be set to false. totalResultSize will contain the total number of results for this query. 
        :param bool include_old: When this flag is set to false, the state without the change will not be returned. The default value is true.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20027
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_changes_with_http_info(**kwargs)  # noqa: E501

    def get_changes_with_http_info(self, **kwargs):  # noqa: E501
        """Get audit log for an account  # noqa: E501

        Get list of changes caused by API calls for an account. Only accessible for admins.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_changes_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param int application_id:
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the change creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the change creation timestamp.
        :param bool with_total_result_size: When this flag is set, the result will include the total size of the result, across all pages. This might decrease performance on large data sets. With this flag set to true, hasMore will be be true whenever there is a next page. totalResultSize will always be zero. With this flag set to false, hasMore will always be set to false. totalResultSize will contain the total number of results for this query. 
        :param bool include_old: When this flag is set to false, the state without the change will not be returned. The default value is true.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20027, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['page_size', 'skip', 'sort', 'application_id', 'created_before', 'created_after', 'with_total_result_size', 'include_old']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_changes" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'application_id' in local_var_params and local_var_params['application_id'] is not None:  # noqa: E501
            query_params.append(('applicationId', local_var_params['application_id']))  # noqa: E501
        if 'created_before' in local_var_params and local_var_params['created_before'] is not None:  # noqa: E501
            query_params.append(('createdBefore', local_var_params['created_before']))  # noqa: E501
        if 'created_after' in local_var_params and local_var_params['created_after'] is not None:  # noqa: E501
            query_params.append(('createdAfter', local_var_params['created_after']))  # noqa: E501
        if 'with_total_result_size' in local_var_params and local_var_params['with_total_result_size'] is not None:  # noqa: E501
            query_params.append(('withTotalResultSize', local_var_params['with_total_result_size']))  # noqa: E501
        if 'include_old' in local_var_params and local_var_params['include_old'] is not None:  # noqa: E501
            query_params.append(('includeOld', local_var_params['include_old']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/changes', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20027',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_coupons(self, application_id, campaign_id, **kwargs):  # noqa: E501
        """List Coupons  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_coupons(application_id, campaign_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime starts_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime starts_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime expires_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime expires_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str batch_id: Filter results by batches of coupons
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_coupons_with_http_info(application_id, campaign_id, **kwargs)  # noqa: E501

    def get_coupons_with_http_info(self, application_id, campaign_id, **kwargs):  # noqa: E501
        """List Coupons  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_coupons_with_http_info(application_id, campaign_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime starts_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime starts_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime expires_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime expires_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str batch_id: Filter results by batches of coupons
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse2001, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'campaign_id', 'page_size', 'skip', 'sort', 'value', 'created_before', 'created_after', 'starts_after', 'starts_before', 'expires_after', 'expires_before', 'valid', 'batch_id', 'usable', 'referral_id', 'recipient_integration_id', 'exact_match']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_coupons" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `get_coupons`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if self.api_client.client_side_validation and ('campaign_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['campaign_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `campaign_id` when calling `get_coupons`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501
        if 'campaign_id' in local_var_params:
            path_params['campaignId'] = local_var_params['campaign_id']  # noqa: E501

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'value' in local_var_params and local_var_params['value'] is not None:  # noqa: E501
            query_params.append(('value', local_var_params['value']))  # noqa: E501
        if 'created_before' in local_var_params and local_var_params['created_before'] is not None:  # noqa: E501
            query_params.append(('createdBefore', local_var_params['created_before']))  # noqa: E501
        if 'created_after' in local_var_params and local_var_params['created_after'] is not None:  # noqa: E501
            query_params.append(('createdAfter', local_var_params['created_after']))  # noqa: E501
        if 'starts_after' in local_var_params and local_var_params['starts_after'] is not None:  # noqa: E501
            query_params.append(('startsAfter', local_var_params['starts_after']))  # noqa: E501
        if 'starts_before' in local_var_params and local_var_params['starts_before'] is not None:  # noqa: E501
            query_params.append(('startsBefore', local_var_params['starts_before']))  # noqa: E501
        if 'expires_after' in local_var_params and local_var_params['expires_after'] is not None:  # noqa: E501
            query_params.append(('expiresAfter', local_var_params['expires_after']))  # noqa: E501
        if 'expires_before' in local_var_params and local_var_params['expires_before'] is not None:  # noqa: E501
            query_params.append(('expiresBefore', local_var_params['expires_before']))  # noqa: E501
        if 'valid' in local_var_params and local_var_params['valid'] is not None:  # noqa: E501
            query_params.append(('valid', local_var_params['valid']))  # noqa: E501
        if 'batch_id' in local_var_params and local_var_params['batch_id'] is not None:  # noqa: E501
            query_params.append(('batchId', local_var_params['batch_id']))  # noqa: E501
        if 'usable' in local_var_params and local_var_params['usable'] is not None:  # noqa: E501
            query_params.append(('usable', local_var_params['usable']))  # noqa: E501
        if 'referral_id' in local_var_params and local_var_params['referral_id'] is not None:  # noqa: E501
            query_params.append(('referralId', local_var_params['referral_id']))  # noqa: E501
        if 'recipient_integration_id' in local_var_params and local_var_params['recipient_integration_id'] is not None:  # noqa: E501
            query_params.append(('recipientIntegrationId', local_var_params['recipient_integration_id']))  # noqa: E501
        if 'exact_match' in local_var_params and local_var_params['exact_match'] is not None:  # noqa: E501
            query_params.append(('exactMatch', local_var_params['exact_match']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2001',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_coupons_by_attributes(self, application_id, campaign_id, body, **kwargs):  # noqa: E501
        """Get a list of the coupons that match the given attributes  # noqa: E501

        Gets a list of all the coupons that exactly match a set of attributes.  The match is successful if all the attributes of the request are found in a coupon, even if the coupon has more attributes that are not present on the request.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_coupons_by_attributes(application_id, campaign_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param CouponSearch body: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :param str batch_id: Filter results by batches of coupons
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_coupons_by_attributes_with_http_info(application_id, campaign_id, body, **kwargs)  # noqa: E501

    def get_coupons_by_attributes_with_http_info(self, application_id, campaign_id, body, **kwargs):  # noqa: E501
        """Get a list of the coupons that match the given attributes  # noqa: E501

        Gets a list of all the coupons that exactly match a set of attributes.  The match is successful if all the attributes of the request are found in a coupon, even if the coupon has more attributes that are not present on the request.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_coupons_by_attributes_with_http_info(application_id, campaign_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param CouponSearch body: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :param str batch_id: Filter results by batches of coupons
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse2001, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'campaign_id', 'body', 'page_size', 'skip', 'sort', 'value', 'created_before', 'created_after', 'valid', 'usable', 'referral_id', 'recipient_integration_id', 'exact_match', 'batch_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_coupons_by_attributes" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `get_coupons_by_attributes`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if self.api_client.client_side_validation and ('campaign_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['campaign_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `campaign_id` when calling `get_coupons_by_attributes`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `get_coupons_by_attributes`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501
        if 'campaign_id' in local_var_params:
            path_params['campaignId'] = local_var_params['campaign_id']  # noqa: E501

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'value' in local_var_params and local_var_params['value'] is not None:  # noqa: E501
            query_params.append(('value', local_var_params['value']))  # noqa: E501
        if 'created_before' in local_var_params and local_var_params['created_before'] is not None:  # noqa: E501
            query_params.append(('createdBefore', local_var_params['created_before']))  # noqa: E501
        if 'created_after' in local_var_params and local_var_params['created_after'] is not None:  # noqa: E501
            query_params.append(('createdAfter', local_var_params['created_after']))  # noqa: E501
        if 'valid' in local_var_params and local_var_params['valid'] is not None:  # noqa: E501
            query_params.append(('valid', local_var_params['valid']))  # noqa: E501
        if 'usable' in local_var_params and local_var_params['usable'] is not None:  # noqa: E501
            query_params.append(('usable', local_var_params['usable']))  # noqa: E501
        if 'referral_id' in local_var_params and local_var_params['referral_id'] is not None:  # noqa: E501
            query_params.append(('referralId', local_var_params['referral_id']))  # noqa: E501
        if 'recipient_integration_id' in local_var_params and local_var_params['recipient_integration_id'] is not None:  # noqa: E501
            query_params.append(('recipientIntegrationId', local_var_params['recipient_integration_id']))  # noqa: E501
        if 'exact_match' in local_var_params and local_var_params['exact_match'] is not None:  # noqa: E501
            query_params.append(('exactMatch', local_var_params['exact_match']))  # noqa: E501
        if 'batch_id' in local_var_params and local_var_params['batch_id'] is not None:  # noqa: E501
            query_params.append(('batchId', local_var_params['batch_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons_search', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2001',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_coupons_by_attributes_application_wide(self, application_id, body, **kwargs):  # noqa: E501
        """Get a list of the coupons that match the given attributes in all active campaigns of an application  # noqa: E501

        Gets a list of all the coupons with attributes matching the query criteria Application wide   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_coupons_by_attributes_application_wide(application_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param CouponSearch body: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param str batch_id: Filter results by batches of coupons
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :param str campaign_state: Filter results by the state of the campaign.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_coupons_by_attributes_application_wide_with_http_info(application_id, body, **kwargs)  # noqa: E501

    def get_coupons_by_attributes_application_wide_with_http_info(self, application_id, body, **kwargs):  # noqa: E501
        """Get a list of the coupons that match the given attributes in all active campaigns of an application  # noqa: E501

        Gets a list of all the coupons with attributes matching the query criteria Application wide   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_coupons_by_attributes_application_wide_with_http_info(application_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param CouponSearch body: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param str batch_id: Filter results by batches of coupons
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :param str campaign_state: Filter results by the state of the campaign.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse2001, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'body', 'page_size', 'skip', 'sort', 'value', 'created_before', 'created_after', 'valid', 'usable', 'referral_id', 'recipient_integration_id', 'batch_id', 'exact_match', 'campaign_state']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_coupons_by_attributes_application_wide" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `get_coupons_by_attributes_application_wide`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `get_coupons_by_attributes_application_wide`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'value' in local_var_params and local_var_params['value'] is not None:  # noqa: E501
            query_params.append(('value', local_var_params['value']))  # noqa: E501
        if 'created_before' in local_var_params and local_var_params['created_before'] is not None:  # noqa: E501
            query_params.append(('createdBefore', local_var_params['created_before']))  # noqa: E501
        if 'created_after' in local_var_params and local_var_params['created_after'] is not None:  # noqa: E501
            query_params.append(('createdAfter', local_var_params['created_after']))  # noqa: E501
        if 'valid' in local_var_params and local_var_params['valid'] is not None:  # noqa: E501
            query_params.append(('valid', local_var_params['valid']))  # noqa: E501
        if 'usable' in local_var_params and local_var_params['usable'] is not None:  # noqa: E501
            query_params.append(('usable', local_var_params['usable']))  # noqa: E501
        if 'referral_id' in local_var_params and local_var_params['referral_id'] is not None:  # noqa: E501
            query_params.append(('referralId', local_var_params['referral_id']))  # noqa: E501
        if 'recipient_integration_id' in local_var_params and local_var_params['recipient_integration_id'] is not None:  # noqa: E501
            query_params.append(('recipientIntegrationId', local_var_params['recipient_integration_id']))  # noqa: E501
        if 'batch_id' in local_var_params and local_var_params['batch_id'] is not None:  # noqa: E501
            query_params.append(('batchId', local_var_params['batch_id']))  # noqa: E501
        if 'exact_match' in local_var_params and local_var_params['exact_match'] is not None:  # noqa: E501
            query_params.append(('exactMatch', local_var_params['exact_match']))  # noqa: E501
        if 'campaign_state' in local_var_params and local_var_params['campaign_state'] is not None:  # noqa: E501
            query_params.append(('campaignState', local_var_params['campaign_state']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/coupons_search', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2001',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_coupons_without_total_count(self, application_id, campaign_id, **kwargs):  # noqa: E501
        """List Coupons  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_coupons_without_total_count(application_id, campaign_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param str batch_id: Filter results by batches of coupons
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_coupons_without_total_count_with_http_info(application_id, campaign_id, **kwargs)  # noqa: E501

    def get_coupons_without_total_count_with_http_info(self, application_id, campaign_id, **kwargs):  # noqa: E501
        """List Coupons  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_coupons_without_total_count_with_http_info(application_id, campaign_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param str batch_id: Filter results by batches of coupons
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse2005, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'campaign_id', 'page_size', 'skip', 'sort', 'value', 'created_before', 'created_after', 'valid', 'usable', 'referral_id', 'recipient_integration_id', 'batch_id', 'exact_match']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_coupons_without_total_count" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `get_coupons_without_total_count`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if self.api_client.client_side_validation and ('campaign_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['campaign_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `campaign_id` when calling `get_coupons_without_total_count`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501
        if 'campaign_id' in local_var_params:
            path_params['campaignId'] = local_var_params['campaign_id']  # noqa: E501

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'value' in local_var_params and local_var_params['value'] is not None:  # noqa: E501
            query_params.append(('value', local_var_params['value']))  # noqa: E501
        if 'created_before' in local_var_params and local_var_params['created_before'] is not None:  # noqa: E501
            query_params.append(('createdBefore', local_var_params['created_before']))  # noqa: E501
        if 'created_after' in local_var_params and local_var_params['created_after'] is not None:  # noqa: E501
            query_params.append(('createdAfter', local_var_params['created_after']))  # noqa: E501
        if 'valid' in local_var_params and local_var_params['valid'] is not None:  # noqa: E501
            query_params.append(('valid', local_var_params['valid']))  # noqa: E501
        if 'usable' in local_var_params and local_var_params['usable'] is not None:  # noqa: E501
            query_params.append(('usable', local_var_params['usable']))  # noqa: E501
        if 'referral_id' in local_var_params and local_var_params['referral_id'] is not None:  # noqa: E501
            query_params.append(('referralId', local_var_params['referral_id']))  # noqa: E501
        if 'recipient_integration_id' in local_var_params and local_var_params['recipient_integration_id'] is not None:  # noqa: E501
            query_params.append(('recipientIntegrationId', local_var_params['recipient_integration_id']))  # noqa: E501
        if 'batch_id' in local_var_params and local_var_params['batch_id'] is not None:  # noqa: E501
            query_params.append(('batchId', local_var_params['batch_id']))  # noqa: E501
        if 'exact_match' in local_var_params and local_var_params['exact_match'] is not None:  # noqa: E501
            query_params.append(('exactMatch', local_var_params['exact_match']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons/no_total', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2005',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_customer_activity_report(self, range_start, range_end, application_id, customer_id, **kwargs):  # noqa: E501
        """Get Activity Report for Single Customer  # noqa: E501

        Fetch summary report for single application customer based on a time range  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customer_activity_report(range_start, range_end, application_id, customer_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime range_start: Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
        :param datetime range_end: Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
        :param int application_id: (required)
        :param int customer_id: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CustomerActivityReport
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_customer_activity_report_with_http_info(range_start, range_end, application_id, customer_id, **kwargs)  # noqa: E501

    def get_customer_activity_report_with_http_info(self, range_start, range_end, application_id, customer_id, **kwargs):  # noqa: E501
        """Get Activity Report for Single Customer  # noqa: E501

        Fetch summary report for single application customer based on a time range  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customer_activity_report_with_http_info(range_start, range_end, application_id, customer_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime range_start: Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
        :param datetime range_end: Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
        :param int application_id: (required)
        :param int customer_id: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CustomerActivityReport, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['range_start', 'range_end', 'application_id', 'customer_id', 'page_size', 'skip']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_customer_activity_report" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'range_start' is set
        if self.api_client.client_side_validation and ('range_start' not in local_var_params or  # noqa: E501
                                                        local_var_params['range_start'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `range_start` when calling `get_customer_activity_report`")  # noqa: E501
        # verify the required parameter 'range_end' is set
        if self.api_client.client_side_validation and ('range_end' not in local_var_params or  # noqa: E501
                                                        local_var_params['range_end'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `range_end` when calling `get_customer_activity_report`")  # noqa: E501
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `get_customer_activity_report`")  # noqa: E501
        # verify the required parameter 'customer_id' is set
        if self.api_client.client_side_validation and ('customer_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['customer_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `customer_id` when calling `get_customer_activity_report`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501
        if 'customer_id' in local_var_params:
            path_params['customerId'] = local_var_params['customer_id']  # noqa: E501

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501
        if 'range_start' in local_var_params and local_var_params['range_start'] is not None:  # noqa: E501
            query_params.append(('rangeStart', local_var_params['range_start']))  # noqa: E501
        if 'range_end' in local_var_params and local_var_params['range_end'] is not None:  # noqa: E501
            query_params.append(('rangeEnd', local_var_params['range_end']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/customer_activity_reports/{customerId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CustomerActivityReport',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_customer_activity_reports(self, range_start, range_end, application_id, **kwargs):  # noqa: E501
        """Get Activity Reports for Application Customers  # noqa: E501

        Fetch summary reports for all application customers based on a time range  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customer_activity_reports(range_start, range_end, application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime range_start: Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
        :param datetime range_end: Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
        :param int application_id: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str name: Only return reports matching the customer name
        :param str integration_id: Only return reports matching the integrationId
        :param str campaign_name: Only return reports matching the campaignName
        :param str advocate_name: Only return reports matching the current customer referrer name
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20014
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_customer_activity_reports_with_http_info(range_start, range_end, application_id, **kwargs)  # noqa: E501

    def get_customer_activity_reports_with_http_info(self, range_start, range_end, application_id, **kwargs):  # noqa: E501
        """Get Activity Reports for Application Customers  # noqa: E501

        Fetch summary reports for all application customers based on a time range  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customer_activity_reports_with_http_info(range_start, range_end, application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime range_start: Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
        :param datetime range_end: Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
        :param int application_id: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str name: Only return reports matching the customer name
        :param str integration_id: Only return reports matching the integrationId
        :param str campaign_name: Only return reports matching the campaignName
        :param str advocate_name: Only return reports matching the current customer referrer name
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20014, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['range_start', 'range_end', 'application_id', 'page_size', 'skip', 'sort', 'name', 'integration_id', 'campaign_name', 'advocate_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_customer_activity_reports" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'range_start' is set
        if self.api_client.client_side_validation and ('range_start' not in local_var_params or  # noqa: E501
                                                        local_var_params['range_start'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `range_start` when calling `get_customer_activity_reports`")  # noqa: E501
        # verify the required parameter 'range_end' is set
        if self.api_client.client_side_validation and ('range_end' not in local_var_params or  # noqa: E501
                                                        local_var_params['range_end'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `range_end` when calling `get_customer_activity_reports`")  # noqa: E501
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `get_customer_activity_reports`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'range_start' in local_var_params and local_var_params['range_start'] is not None:  # noqa: E501
            query_params.append(('rangeStart', local_var_params['range_start']))  # noqa: E501
        if 'range_end' in local_var_params and local_var_params['range_end'] is not None:  # noqa: E501
            query_params.append(('rangeEnd', local_var_params['range_end']))  # noqa: E501
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'integration_id' in local_var_params and local_var_params['integration_id'] is not None:  # noqa: E501
            query_params.append(('integrationId', local_var_params['integration_id']))  # noqa: E501
        if 'campaign_name' in local_var_params and local_var_params['campaign_name'] is not None:  # noqa: E501
            query_params.append(('campaignName', local_var_params['campaign_name']))  # noqa: E501
        if 'advocate_name' in local_var_params and local_var_params['advocate_name'] is not None:  # noqa: E501
            query_params.append(('advocateName', local_var_params['advocate_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/customer_activity_reports', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20014',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_customer_activity_reports_without_total_count(self, range_start, range_end, application_id, **kwargs):  # noqa: E501
        """Get Activity Reports for Application Customers  # noqa: E501

        Fetch summary reports for all application customers based on a time range. Instead of having the total number of results in the response, this endpoint only if there are more results.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customer_activity_reports_without_total_count(range_start, range_end, application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime range_start: Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
        :param datetime range_end: Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
        :param int application_id: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str name: Only return reports matching the customer name
        :param str integration_id: Only return reports matching the integrationId
        :param str campaign_name: Only return reports matching the campaignName
        :param str advocate_name: Only return reports matching the current customer referrer name
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20015
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_customer_activity_reports_without_total_count_with_http_info(range_start, range_end, application_id, **kwargs)  # noqa: E501

    def get_customer_activity_reports_without_total_count_with_http_info(self, range_start, range_end, application_id, **kwargs):  # noqa: E501
        """Get Activity Reports for Application Customers  # noqa: E501

        Fetch summary reports for all application customers based on a time range. Instead of having the total number of results in the response, this endpoint only if there are more results.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customer_activity_reports_without_total_count_with_http_info(range_start, range_end, application_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param datetime range_start: Only return results from after this timestamp, must be an RFC3339 timestamp string (required)
        :param datetime range_end: Only return results from before this timestamp, must be an RFC3339 timestamp string (required)
        :param int application_id: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str name: Only return reports matching the customer name
        :param str integration_id: Only return reports matching the integrationId
        :param str campaign_name: Only return reports matching the campaignName
        :param str advocate_name: Only return reports matching the current customer referrer name
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20015, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['range_start', 'range_end', 'application_id', 'page_size', 'skip', 'sort', 'name', 'integration_id', 'campaign_name', 'advocate_name']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_customer_activity_reports_without_total_count" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'range_start' is set
        if self.api_client.client_side_validation and ('range_start' not in local_var_params or  # noqa: E501
                                                        local_var_params['range_start'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `range_start` when calling `get_customer_activity_reports_without_total_count`")  # noqa: E501
        # verify the required parameter 'range_end' is set
        if self.api_client.client_side_validation and ('range_end' not in local_var_params or  # noqa: E501
                                                        local_var_params['range_end'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `range_end` when calling `get_customer_activity_reports_without_total_count`")  # noqa: E501
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `get_customer_activity_reports_without_total_count`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'range_start' in local_var_params and local_var_params['range_start'] is not None:  # noqa: E501
            query_params.append(('rangeStart', local_var_params['range_start']))  # noqa: E501
        if 'range_end' in local_var_params and local_var_params['range_end'] is not None:  # noqa: E501
            query_params.append(('rangeEnd', local_var_params['range_end']))  # noqa: E501
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'integration_id' in local_var_params and local_var_params['integration_id'] is not None:  # noqa: E501
            query_params.append(('integrationId', local_var_params['integration_id']))  # noqa: E501
        if 'campaign_name' in local_var_params and local_var_params['campaign_name'] is not None:  # noqa: E501
            query_params.append(('campaignName', local_var_params['campaign_name']))  # noqa: E501
        if 'advocate_name' in local_var_params and local_var_params['advocate_name'] is not None:  # noqa: E501
            query_params.append(('advocateName', local_var_params['advocate_name']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/customer_activity_reports/no_total', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20015',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_customer_analytics(self, application_id, customer_id, **kwargs):  # noqa: E501
        """Get Analytics Report for a Customer  # noqa: E501

        Fetch analytics for single application customer  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customer_analytics(application_id, customer_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int customer_id: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CustomerAnalytics
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_customer_analytics_with_http_info(application_id, customer_id, **kwargs)  # noqa: E501

    def get_customer_analytics_with_http_info(self, application_id, customer_id, **kwargs):  # noqa: E501
        """Get Analytics Report for a Customer  # noqa: E501

        Fetch analytics for single application customer  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customer_analytics_with_http_info(application_id, customer_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int customer_id: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CustomerAnalytics, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'customer_id', 'page_size', 'skip', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_customer_analytics" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `get_customer_analytics`")  # noqa: E501
        # verify the required parameter 'customer_id' is set
        if self.api_client.client_side_validation and ('customer_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['customer_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `customer_id` when calling `get_customer_analytics`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501
        if 'customer_id' in local_var_params:
            path_params['customerId'] = local_var_params['customer_id']  # noqa: E501

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/customers/{customerId}/analytics', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CustomerAnalytics',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_customer_profile(self, application_id, customer_id, **kwargs):  # noqa: E501
        """Get Customer Profile  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customer_profile(application_id, customer_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int customer_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: ApplicationCustomer
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_customer_profile_with_http_info(application_id, customer_id, **kwargs)  # noqa: E501

    def get_customer_profile_with_http_info(self, application_id, customer_id, **kwargs):  # noqa: E501
        """Get Customer Profile  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customer_profile_with_http_info(application_id, customer_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int customer_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(ApplicationCustomer, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'customer_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_customer_profile" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `get_customer_profile`")  # noqa: E501
        # verify the required parameter 'customer_id' is set
        if self.api_client.client_side_validation and ('customer_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['customer_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `customer_id` when calling `get_customer_profile`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501
        if 'customer_id' in local_var_params:
            path_params['customerId'] = local_var_params['customer_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/customers/{customerId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='ApplicationCustomer',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_customer_profiles(self, **kwargs):  # noqa: E501
        """List Customer Profiles  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customer_profiles(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20013
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_customer_profiles_with_http_info(**kwargs)  # noqa: E501

    def get_customer_profiles_with_http_info(self, **kwargs):  # noqa: E501
        """List Customer Profiles  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customer_profiles_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20013, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['page_size', 'skip']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_customer_profiles" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/customers/no_total', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20013',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_customers_by_attributes(self, body, **kwargs):  # noqa: E501
        """Get a list of the customer profiles that match the given attributes  # noqa: E501

        Gets a list of all the customer profiles for the account that exactly match a set of attributes.  The match is successful if all the attributes of the request are found in a profile, even if the profile has more attributes that are not present on the request.  [Customer Profile]: https://help.talon.one/hc/en-us/articles/360005130739-Data-Model#CustomerProfile   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customers_by_attributes(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ApplicationCustomerSearch body: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20013
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_customers_by_attributes_with_http_info(body, **kwargs)  # noqa: E501

    def get_customers_by_attributes_with_http_info(self, body, **kwargs):  # noqa: E501
        """Get a list of the customer profiles that match the given attributes  # noqa: E501

        Gets a list of all the customer profiles for the account that exactly match a set of attributes.  The match is successful if all the attributes of the request are found in a profile, even if the profile has more attributes that are not present on the request.  [Customer Profile]: https://help.talon.one/hc/en-us/articles/360005130739-Data-Model#CustomerProfile   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_customers_by_attributes_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param ApplicationCustomerSearch body: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20013, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['body', 'page_size', 'skip']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_customers_by_attributes" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `get_customers_by_attributes`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/customer_search/no_total', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20013',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_event_types(self, **kwargs):  # noqa: E501
        """List Event Types  # noqa: E501

        Fetch all event type definitions for your account. Each event type can be   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_event_types(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str application_ids: Filter by one or more application ids separated by comma
        :param str name: Filter results to event types with the given name. This parameter implies `includeOldVersions`.
        :param bool include_old_versions: Include all versions of every event type.
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20025
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_event_types_with_http_info(**kwargs)  # noqa: E501

    def get_event_types_with_http_info(self, **kwargs):  # noqa: E501
        """List Event Types  # noqa: E501

        Fetch all event type definitions for your account. Each event type can be   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_event_types_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str application_ids: Filter by one or more application ids separated by comma
        :param str name: Filter results to event types with the given name. This parameter implies `includeOldVersions`.
        :param bool include_old_versions: Include all versions of every event type.
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20025, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_ids', 'name', 'include_old_versions', 'page_size', 'skip', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_event_types" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'application_ids' in local_var_params and local_var_params['application_ids'] is not None:  # noqa: E501
            query_params.append(('applicationIds', local_var_params['application_ids']))  # noqa: E501
        if 'name' in local_var_params and local_var_params['name'] is not None:  # noqa: E501
            query_params.append(('name', local_var_params['name']))  # noqa: E501
        if 'include_old_versions' in local_var_params and local_var_params['include_old_versions'] is not None:  # noqa: E501
            query_params.append(('includeOldVersions', local_var_params['include_old_versions']))  # noqa: E501
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/event_types', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20025',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_exports(self, **kwargs):  # noqa: E501
        """Get Exports  # noqa: E501

        Get a list of all past exports   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_exports(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param int application_id:
        :param int campaign_id:
        :param str entity: The name of the entity type that was exported.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20028
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_exports_with_http_info(**kwargs)  # noqa: E501

    def get_exports_with_http_info(self, **kwargs):  # noqa: E501
        """Get Exports  # noqa: E501

        Get a list of all past exports   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_exports_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param int application_id:
        :param int campaign_id:
        :param str entity: The name of the entity type that was exported.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20028, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['page_size', 'skip', 'application_id', 'campaign_id', 'entity']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_exports" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501
        if 'application_id' in local_var_params and local_var_params['application_id'] is not None:  # noqa: E501
            query_params.append(('applicationId', local_var_params['application_id']))  # noqa: E501
        if 'campaign_id' in local_var_params and local_var_params['campaign_id'] is not None:  # noqa: E501
            query_params.append(('campaignId', local_var_params['campaign_id']))  # noqa: E501
        if 'entity' in local_var_params and local_var_params['entity'] is not None:  # noqa: E501
            query_params.append(('entity', local_var_params['entity']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/exports', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20028',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_imports(self, **kwargs):  # noqa: E501
        """Get Imports  # noqa: E501

        Get a list of all past imports   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_imports(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20029
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_imports_with_http_info(**kwargs)  # noqa: E501

    def get_imports_with_http_info(self, **kwargs):  # noqa: E501
        """Get Imports  # noqa: E501

        Get a list of all past imports   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_imports_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20029, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['page_size', 'skip']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_imports" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/imports', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20029',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_loyalty_points(self, program_id, integration_id, **kwargs):  # noqa: E501
        """get the Loyalty Ledger for this integrationID  # noqa: E501

        Get the Loyalty Ledger for this profile integration ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_loyalty_points(program_id, integration_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str program_id: The identifier for the application, must be unique within the account. (required)
        :param str integration_id: The identifier for the application, must be unique within the account. (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LoyaltyLedger
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_loyalty_points_with_http_info(program_id, integration_id, **kwargs)  # noqa: E501

    def get_loyalty_points_with_http_info(self, program_id, integration_id, **kwargs):  # noqa: E501
        """get the Loyalty Ledger for this integrationID  # noqa: E501

        Get the Loyalty Ledger for this profile integration ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_loyalty_points_with_http_info(program_id, integration_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str program_id: The identifier for the application, must be unique within the account. (required)
        :param str integration_id: The identifier for the application, must be unique within the account. (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LoyaltyLedger, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['program_id', 'integration_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_loyalty_points" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'program_id' is set
        if self.api_client.client_side_validation and ('program_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['program_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `program_id` when calling `get_loyalty_points`")  # noqa: E501
        # verify the required parameter 'integration_id' is set
        if self.api_client.client_side_validation and ('integration_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['integration_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `integration_id` when calling `get_loyalty_points`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'program_id' in local_var_params:
            path_params['programID'] = local_var_params['program_id']  # noqa: E501
        if 'integration_id' in local_var_params:
            path_params['integrationID'] = local_var_params['integration_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/loyalty_programs/{programID}/profile/{integrationID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LoyaltyLedger',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_loyalty_program(self, program_id, **kwargs):  # noqa: E501
        """Get a loyalty program  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_loyalty_program(program_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str program_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: LoyaltyProgram
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_loyalty_program_with_http_info(program_id, **kwargs)  # noqa: E501

    def get_loyalty_program_with_http_info(self, program_id, **kwargs):  # noqa: E501
        """Get a loyalty program  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_loyalty_program_with_http_info(program_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str program_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(LoyaltyProgram, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['program_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_loyalty_program" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'program_id' is set
        if self.api_client.client_side_validation and ('program_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['program_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `program_id` when calling `get_loyalty_program`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'program_id' in local_var_params:
            path_params['programID'] = local_var_params['program_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/loyalty_programs/{programID}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LoyaltyProgram',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_loyalty_programs(self, **kwargs):  # noqa: E501
        """List all loyalty Programs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_loyalty_programs(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_loyalty_programs_with_http_info(**kwargs)  # noqa: E501

    def get_loyalty_programs_with_http_info(self, **kwargs):  # noqa: E501
        """List all loyalty Programs  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_loyalty_programs_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse2008, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_loyalty_programs" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/loyalty_programs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2008',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_referrals(self, application_id, campaign_id, **kwargs):  # noqa: E501
        """List Referrals  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_referrals(application_id, campaign_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str code: Filter results performing case-insensitive matching against the referral code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches referrals in which the expiry date is set and in the past. The second matches referrals in which start date is null or in the past and expiry date is null or in the future, the third matches referrals in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only referrals where `usageCounter < usageLimit` will be returned, \"false\" will return only referrals where `usageCounter >= usageLimit`. 
        :param str advocate: Filter results by match with a profile id specified in the referral's AdvocateProfileIntegrationId field
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_referrals_with_http_info(application_id, campaign_id, **kwargs)  # noqa: E501

    def get_referrals_with_http_info(self, application_id, campaign_id, **kwargs):  # noqa: E501
        """List Referrals  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_referrals_with_http_info(application_id, campaign_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str code: Filter results performing case-insensitive matching against the referral code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches referrals in which the expiry date is set and in the past. The second matches referrals in which start date is null or in the past and expiry date is null or in the future, the third matches referrals in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only referrals where `usageCounter < usageLimit` will be returned, \"false\" will return only referrals where `usageCounter >= usageLimit`. 
        :param str advocate: Filter results by match with a profile id specified in the referral's AdvocateProfileIntegrationId field
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse2006, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'campaign_id', 'page_size', 'skip', 'sort', 'code', 'created_before', 'created_after', 'valid', 'usable', 'advocate']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_referrals" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `get_referrals`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if self.api_client.client_side_validation and ('campaign_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['campaign_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `campaign_id` when calling `get_referrals`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501
        if 'campaign_id' in local_var_params:
            path_params['campaignId'] = local_var_params['campaign_id']  # noqa: E501

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'code' in local_var_params and local_var_params['code'] is not None:  # noqa: E501
            query_params.append(('code', local_var_params['code']))  # noqa: E501
        if 'created_before' in local_var_params and local_var_params['created_before'] is not None:  # noqa: E501
            query_params.append(('createdBefore', local_var_params['created_before']))  # noqa: E501
        if 'created_after' in local_var_params and local_var_params['created_after'] is not None:  # noqa: E501
            query_params.append(('createdAfter', local_var_params['created_after']))  # noqa: E501
        if 'valid' in local_var_params and local_var_params['valid'] is not None:  # noqa: E501
            query_params.append(('valid', local_var_params['valid']))  # noqa: E501
        if 'usable' in local_var_params and local_var_params['usable'] is not None:  # noqa: E501
            query_params.append(('usable', local_var_params['usable']))  # noqa: E501
        if 'advocate' in local_var_params and local_var_params['advocate'] is not None:  # noqa: E501
            query_params.append(('advocate', local_var_params['advocate']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/referrals', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2006',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_referrals_without_total_count(self, application_id, campaign_id, **kwargs):  # noqa: E501
        """List Referrals  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_referrals_without_total_count(application_id, campaign_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str code: Filter results performing case-insensitive matching against the referral code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches referrals in which the expiry date is set and in the past. The second matches referrals in which start date is null or in the past and expiry date is null or in the future, the third matches referrals in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only referrals where `usageCounter < usageLimit` will be returned, \"false\" will return only referrals where `usageCounter >= usageLimit`. 
        :param str advocate: Filter results by match with a profile id specified in the referral's AdvocateProfileIntegrationId field
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse2007
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_referrals_without_total_count_with_http_info(application_id, campaign_id, **kwargs)  # noqa: E501

    def get_referrals_without_total_count_with_http_info(self, application_id, campaign_id, **kwargs):  # noqa: E501
        """List Referrals  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_referrals_without_total_count_with_http_info(application_id, campaign_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str code: Filter results performing case-insensitive matching against the referral code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the referral creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches referrals in which the expiry date is set and in the past. The second matches referrals in which start date is null or in the past and expiry date is null or in the future, the third matches referrals in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only referrals where `usageCounter < usageLimit` will be returned, \"false\" will return only referrals where `usageCounter >= usageLimit`. 
        :param str advocate: Filter results by match with a profile id specified in the referral's AdvocateProfileIntegrationId field
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse2007, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'campaign_id', 'page_size', 'skip', 'sort', 'code', 'created_before', 'created_after', 'valid', 'usable', 'advocate']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_referrals_without_total_count" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `get_referrals_without_total_count`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if self.api_client.client_side_validation and ('campaign_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['campaign_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `campaign_id` when calling `get_referrals_without_total_count`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501
        if 'campaign_id' in local_var_params:
            path_params['campaignId'] = local_var_params['campaign_id']  # noqa: E501

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'code' in local_var_params and local_var_params['code'] is not None:  # noqa: E501
            query_params.append(('code', local_var_params['code']))  # noqa: E501
        if 'created_before' in local_var_params and local_var_params['created_before'] is not None:  # noqa: E501
            query_params.append(('createdBefore', local_var_params['created_before']))  # noqa: E501
        if 'created_after' in local_var_params and local_var_params['created_after'] is not None:  # noqa: E501
            query_params.append(('createdAfter', local_var_params['created_after']))  # noqa: E501
        if 'valid' in local_var_params and local_var_params['valid'] is not None:  # noqa: E501
            query_params.append(('valid', local_var_params['valid']))  # noqa: E501
        if 'usable' in local_var_params and local_var_params['usable'] is not None:  # noqa: E501
            query_params.append(('usable', local_var_params['usable']))  # noqa: E501
        if 'advocate' in local_var_params and local_var_params['advocate'] is not None:  # noqa: E501
            query_params.append(('advocate', local_var_params['advocate']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/referrals/no_total', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2007',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_role(self, role_id, **kwargs):  # noqa: E501
        """Get information for the specified role.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_role(role_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int role_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Role
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_role_with_http_info(role_id, **kwargs)  # noqa: E501

    def get_role_with_http_info(self, role_id, **kwargs):  # noqa: E501
        """Get information for the specified role.  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_role_with_http_info(role_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int role_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Role, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['role_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_role" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'role_id' is set
        if self.api_client.client_side_validation and ('role_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['role_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `role_id` when calling `get_role`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'role_id' in local_var_params:
            path_params['roleId'] = local_var_params['role_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/roles/{roleId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Role',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_ruleset(self, application_id, campaign_id, ruleset_id, **kwargs):  # noqa: E501
        """Get a Ruleset  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ruleset(application_id, campaign_id, ruleset_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param int ruleset_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Ruleset
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_ruleset_with_http_info(application_id, campaign_id, ruleset_id, **kwargs)  # noqa: E501

    def get_ruleset_with_http_info(self, application_id, campaign_id, ruleset_id, **kwargs):  # noqa: E501
        """Get a Ruleset  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_ruleset_with_http_info(application_id, campaign_id, ruleset_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param int ruleset_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Ruleset, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'campaign_id', 'ruleset_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_ruleset" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `get_ruleset`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if self.api_client.client_side_validation and ('campaign_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['campaign_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `campaign_id` when calling `get_ruleset`")  # noqa: E501
        # verify the required parameter 'ruleset_id' is set
        if self.api_client.client_side_validation and ('ruleset_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['ruleset_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `ruleset_id` when calling `get_ruleset`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501
        if 'campaign_id' in local_var_params:
            path_params['campaignId'] = local_var_params['campaign_id']  # noqa: E501
        if 'ruleset_id' in local_var_params:
            path_params['rulesetId'] = local_var_params['ruleset_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/rulesets/{rulesetId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Ruleset',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_rulesets(self, application_id, campaign_id, **kwargs):  # noqa: E501
        """List Campaign Rulesets  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_rulesets(application_id, campaign_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse2004
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_rulesets_with_http_info(application_id, campaign_id, **kwargs)  # noqa: E501

    def get_rulesets_with_http_info(self, application_id, campaign_id, **kwargs):  # noqa: E501
        """List Campaign Rulesets  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_rulesets_with_http_info(application_id, campaign_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse2004, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'campaign_id', 'page_size', 'skip', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_rulesets" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `get_rulesets`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if self.api_client.client_side_validation and ('campaign_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['campaign_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `campaign_id` when calling `get_rulesets`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501
        if 'campaign_id' in local_var_params:
            path_params['campaignId'] = local_var_params['campaign_id']  # noqa: E501

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/rulesets', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2004',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_user(self, user_id, **kwargs):  # noqa: E501
        """Get a single User  # noqa: E501

        Retrieves the data (including an invitation code) for a user. Non-admin users can only get themselves.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int user_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: User
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_user_with_http_info(user_id, **kwargs)  # noqa: E501

    def get_user_with_http_info(self, user_id, **kwargs):  # noqa: E501
        """Get a single User  # noqa: E501

        Retrieves the data (including an invitation code) for a user. Non-admin users can only get themselves.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_user_with_http_info(user_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int user_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(User, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['user_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_user" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'user_id' is set
        if self.api_client.client_side_validation and ('user_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['user_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `user_id` when calling `get_user`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'user_id' in local_var_params:
            path_params['userId'] = local_var_params['user_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/users/{userId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='User',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_users(self, **kwargs):  # noqa: E501
        """List Users in your account  # noqa: E501

        Retrieve all users in your account.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_users(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20026
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_users_with_http_info(**kwargs)  # noqa: E501

    def get_users_with_http_info(self, **kwargs):  # noqa: E501
        """List Users in your account  # noqa: E501

        Retrieve all users in your account.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_users_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20026, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['page_size', 'skip', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_users" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/users', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20026',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_webhook(self, webhook_id, **kwargs):  # noqa: E501
        """Get Webhook  # noqa: E501

        Returns an webhook by its id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_webhook(webhook_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int webhook_id: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Webhook
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_webhook_with_http_info(webhook_id, **kwargs)  # noqa: E501

    def get_webhook_with_http_info(self, webhook_id, **kwargs):  # noqa: E501
        """Get Webhook  # noqa: E501

        Returns an webhook by its id.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_webhook_with_http_info(webhook_id, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int webhook_id: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Webhook, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['webhook_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_webhook" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'webhook_id' is set
        if self.api_client.client_side_validation and ('webhook_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['webhook_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `webhook_id` when calling `get_webhook`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'webhook_id' in local_var_params:
            path_params['webhookId'] = local_var_params['webhook_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/webhooks/{webhookId}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Webhook',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_webhook_activation_logs(self, **kwargs):  # noqa: E501
        """List Webhook activation Log Entries  # noqa: E501

        Webhook activation log entries would be created as soon as an integration request triggered an effect with a webhook  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_webhook_activation_logs(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str integration_request_uuid: Filter results by integration request UUID.
        :param float webhook_id: Filter results by Webhook.
        :param float application_id:
        :param float campaign_id: Filter results by campaign.
        :param datetime created_before: Only return events created before this date.
        :param datetime created_after: Filter results where request and response times to return entries after parameter value, expected to be an RFC3339 timestamp string.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20023
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_webhook_activation_logs_with_http_info(**kwargs)  # noqa: E501

    def get_webhook_activation_logs_with_http_info(self, **kwargs):  # noqa: E501
        """List Webhook activation Log Entries  # noqa: E501

        Webhook activation log entries would be created as soon as an integration request triggered an effect with a webhook  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_webhook_activation_logs_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str integration_request_uuid: Filter results by integration request UUID.
        :param float webhook_id: Filter results by Webhook.
        :param float application_id:
        :param float campaign_id: Filter results by campaign.
        :param datetime created_before: Only return events created before this date.
        :param datetime created_after: Filter results where request and response times to return entries after parameter value, expected to be an RFC3339 timestamp string.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20023, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['page_size', 'skip', 'sort', 'integration_request_uuid', 'webhook_id', 'application_id', 'campaign_id', 'created_before', 'created_after']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_webhook_activation_logs" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'integration_request_uuid' in local_var_params and local_var_params['integration_request_uuid'] is not None:  # noqa: E501
            query_params.append(('integrationRequestUuid', local_var_params['integration_request_uuid']))  # noqa: E501
        if 'webhook_id' in local_var_params and local_var_params['webhook_id'] is not None:  # noqa: E501
            query_params.append(('webhookId', local_var_params['webhook_id']))  # noqa: E501
        if 'application_id' in local_var_params and local_var_params['application_id'] is not None:  # noqa: E501
            query_params.append(('applicationId', local_var_params['application_id']))  # noqa: E501
        if 'campaign_id' in local_var_params and local_var_params['campaign_id'] is not None:  # noqa: E501
            query_params.append(('campaignId', local_var_params['campaign_id']))  # noqa: E501
        if 'created_before' in local_var_params and local_var_params['created_before'] is not None:  # noqa: E501
            query_params.append(('createdBefore', local_var_params['created_before']))  # noqa: E501
        if 'created_after' in local_var_params and local_var_params['created_after'] is not None:  # noqa: E501
            query_params.append(('createdAfter', local_var_params['created_after']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/webhook_activation_logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20023',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_webhook_logs(self, **kwargs):  # noqa: E501
        """List Webhook Log Entries  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_webhook_logs(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str status: Filter results by HTTP status codes.
        :param float webhook_id: Filter results by Webhook.
        :param float application_id:
        :param float campaign_id: Filter results by campaign.
        :param str request_uuid: Filter results by request UUID.
        :param datetime created_before: Filter results where request and response times to return entries before parameter value, expected to be an RFC3339 timestamp string.
        :param datetime created_after: Filter results where request and response times to return entries after parameter value, expected to be an RFC3339 timestamp string.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20024
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_webhook_logs_with_http_info(**kwargs)  # noqa: E501

    def get_webhook_logs_with_http_info(self, **kwargs):  # noqa: E501
        """List Webhook Log Entries  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_webhook_logs_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str status: Filter results by HTTP status codes.
        :param float webhook_id: Filter results by Webhook.
        :param float application_id:
        :param float campaign_id: Filter results by campaign.
        :param str request_uuid: Filter results by request UUID.
        :param datetime created_before: Filter results where request and response times to return entries before parameter value, expected to be an RFC3339 timestamp string.
        :param datetime created_after: Filter results where request and response times to return entries after parameter value, expected to be an RFC3339 timestamp string.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20024, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['page_size', 'skip', 'sort', 'status', 'webhook_id', 'application_id', 'campaign_id', 'request_uuid', 'created_before', 'created_after']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_webhook_logs" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'status' in local_var_params and local_var_params['status'] is not None:  # noqa: E501
            query_params.append(('status', local_var_params['status']))  # noqa: E501
        if 'webhook_id' in local_var_params and local_var_params['webhook_id'] is not None:  # noqa: E501
            query_params.append(('webhookId', local_var_params['webhook_id']))  # noqa: E501
        if 'application_id' in local_var_params and local_var_params['application_id'] is not None:  # noqa: E501
            query_params.append(('applicationId', local_var_params['application_id']))  # noqa: E501
        if 'campaign_id' in local_var_params and local_var_params['campaign_id'] is not None:  # noqa: E501
            query_params.append(('campaignId', local_var_params['campaign_id']))  # noqa: E501
        if 'request_uuid' in local_var_params and local_var_params['request_uuid'] is not None:  # noqa: E501
            query_params.append(('requestUuid', local_var_params['request_uuid']))  # noqa: E501
        if 'created_before' in local_var_params and local_var_params['created_before'] is not None:  # noqa: E501
            query_params.append(('createdBefore', local_var_params['created_before']))  # noqa: E501
        if 'created_after' in local_var_params and local_var_params['created_after'] is not None:  # noqa: E501
            query_params.append(('createdAfter', local_var_params['created_after']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/webhook_logs', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20024',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_webhooks(self, **kwargs):  # noqa: E501
        """List Webhooks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_webhooks(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str application_ids: Filter by one or more application ids separated by comma
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse20022
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.get_webhooks_with_http_info(**kwargs)  # noqa: E501

    def get_webhooks_with_http_info(self, **kwargs):  # noqa: E501
        """List Webhooks  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_webhooks_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str application_ids: Filter by one or more application ids separated by comma
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse20022, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_ids', 'sort', 'page_size', 'skip']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_webhooks" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'application_ids' in local_var_params and local_var_params['application_ids'] is not None:  # noqa: E501
            query_params.append(('applicationIds', local_var_params['application_ids']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/webhooks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20022',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def remove_loyalty_points(self, program_id, integration_id, body, **kwargs):  # noqa: E501
        """Deduct points in a certain loyalty program for the specified customer  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_loyalty_points(program_id, integration_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str program_id: (required)
        :param str integration_id: (required)
        :param LoyaltyPoints body: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.remove_loyalty_points_with_http_info(program_id, integration_id, body, **kwargs)  # noqa: E501

    def remove_loyalty_points_with_http_info(self, program_id, integration_id, body, **kwargs):  # noqa: E501
        """Deduct points in a certain loyalty program for the specified customer  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.remove_loyalty_points_with_http_info(program_id, integration_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param str program_id: (required)
        :param str integration_id: (required)
        :param LoyaltyPoints body: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['program_id', 'integration_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method remove_loyalty_points" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'program_id' is set
        if self.api_client.client_side_validation and ('program_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['program_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `program_id` when calling `remove_loyalty_points`")  # noqa: E501
        # verify the required parameter 'integration_id' is set
        if self.api_client.client_side_validation and ('integration_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['integration_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `integration_id` when calling `remove_loyalty_points`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `remove_loyalty_points`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'program_id' in local_var_params:
            path_params['programID'] = local_var_params['program_id']  # noqa: E501
        if 'integration_id' in local_var_params:
            path_params['integrationID'] = local_var_params['integration_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/loyalty_programs/{programID}/profile/{integrationID}/deduct_points', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def reset_password(self, body, **kwargs):  # noqa: E501
        """Reset password  # noqa: E501

        Consumes the supplied password reset token and updates the password for the associated account.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reset_password(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param NewPassword body: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: NewPassword
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.reset_password_with_http_info(body, **kwargs)  # noqa: E501

    def reset_password_with_http_info(self, body, **kwargs):  # noqa: E501
        """Reset password  # noqa: E501

        Consumes the supplied password reset token and updates the password for the associated account.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.reset_password_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param NewPassword body: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(NewPassword, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method reset_password" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `reset_password`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/reset_password', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='NewPassword',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_coupons_advanced(self, application_id, campaign_id, body, **kwargs):  # noqa: E501
        """Get a list of the coupons that match the given attributes  # noqa: E501

        Gets a list of all the coupons with attributes matching the query criteria   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_coupons_advanced(application_id, campaign_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param object body: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :param str batch_id: Filter results by batches of coupons
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.search_coupons_advanced_with_http_info(application_id, campaign_id, body, **kwargs)  # noqa: E501

    def search_coupons_advanced_with_http_info(self, application_id, campaign_id, body, **kwargs):  # noqa: E501
        """Get a list of the coupons that match the given attributes  # noqa: E501

        Gets a list of all the coupons with attributes matching the query criteria   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_coupons_advanced_with_http_info(application_id, campaign_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param object body: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :param str batch_id: Filter results by batches of coupons
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse2001, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'campaign_id', 'body', 'page_size', 'skip', 'sort', 'value', 'created_before', 'created_after', 'valid', 'usable', 'referral_id', 'recipient_integration_id', 'exact_match', 'batch_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_coupons_advanced" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `search_coupons_advanced`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if self.api_client.client_side_validation and ('campaign_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['campaign_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `campaign_id` when calling `search_coupons_advanced`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `search_coupons_advanced`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501
        if 'campaign_id' in local_var_params:
            path_params['campaignId'] = local_var_params['campaign_id']  # noqa: E501

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'value' in local_var_params and local_var_params['value'] is not None:  # noqa: E501
            query_params.append(('value', local_var_params['value']))  # noqa: E501
        if 'created_before' in local_var_params and local_var_params['created_before'] is not None:  # noqa: E501
            query_params.append(('createdBefore', local_var_params['created_before']))  # noqa: E501
        if 'created_after' in local_var_params and local_var_params['created_after'] is not None:  # noqa: E501
            query_params.append(('createdAfter', local_var_params['created_after']))  # noqa: E501
        if 'valid' in local_var_params and local_var_params['valid'] is not None:  # noqa: E501
            query_params.append(('valid', local_var_params['valid']))  # noqa: E501
        if 'usable' in local_var_params and local_var_params['usable'] is not None:  # noqa: E501
            query_params.append(('usable', local_var_params['usable']))  # noqa: E501
        if 'referral_id' in local_var_params and local_var_params['referral_id'] is not None:  # noqa: E501
            query_params.append(('referralId', local_var_params['referral_id']))  # noqa: E501
        if 'recipient_integration_id' in local_var_params and local_var_params['recipient_integration_id'] is not None:  # noqa: E501
            query_params.append(('recipientIntegrationId', local_var_params['recipient_integration_id']))  # noqa: E501
        if 'exact_match' in local_var_params and local_var_params['exact_match'] is not None:  # noqa: E501
            query_params.append(('exactMatch', local_var_params['exact_match']))  # noqa: E501
        if 'batch_id' in local_var_params and local_var_params['batch_id'] is not None:  # noqa: E501
            query_params.append(('batchId', local_var_params['batch_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons_search_advanced', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2001',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_coupons_advanced_application_wide(self, application_id, body, **kwargs):  # noqa: E501
        """Get a list of the coupons that match the given attributes in all active campaigns of an application  # noqa: E501

        Gets a list of all the coupons with attributes matching the query criteria in all active campaigns of an application   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_coupons_advanced_application_wide(application_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param object body: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param str batch_id: Filter results by batches of coupons
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :param str campaign_state: Filter results by the state of the campaign.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.search_coupons_advanced_application_wide_with_http_info(application_id, body, **kwargs)  # noqa: E501

    def search_coupons_advanced_application_wide_with_http_info(self, application_id, body, **kwargs):  # noqa: E501
        """Get a list of the coupons that match the given attributes in all active campaigns of an application  # noqa: E501

        Gets a list of all the coupons with attributes matching the query criteria in all active campaigns of an application   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_coupons_advanced_application_wide_with_http_info(application_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param object body: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param str batch_id: Filter results by batches of coupons
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :param str campaign_state: Filter results by the state of the campaign.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse2001, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'body', 'page_size', 'skip', 'sort', 'value', 'created_before', 'created_after', 'valid', 'usable', 'referral_id', 'recipient_integration_id', 'batch_id', 'exact_match', 'campaign_state']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_coupons_advanced_application_wide" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `search_coupons_advanced_application_wide`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `search_coupons_advanced_application_wide`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'value' in local_var_params and local_var_params['value'] is not None:  # noqa: E501
            query_params.append(('value', local_var_params['value']))  # noqa: E501
        if 'created_before' in local_var_params and local_var_params['created_before'] is not None:  # noqa: E501
            query_params.append(('createdBefore', local_var_params['created_before']))  # noqa: E501
        if 'created_after' in local_var_params and local_var_params['created_after'] is not None:  # noqa: E501
            query_params.append(('createdAfter', local_var_params['created_after']))  # noqa: E501
        if 'valid' in local_var_params and local_var_params['valid'] is not None:  # noqa: E501
            query_params.append(('valid', local_var_params['valid']))  # noqa: E501
        if 'usable' in local_var_params and local_var_params['usable'] is not None:  # noqa: E501
            query_params.append(('usable', local_var_params['usable']))  # noqa: E501
        if 'referral_id' in local_var_params and local_var_params['referral_id'] is not None:  # noqa: E501
            query_params.append(('referralId', local_var_params['referral_id']))  # noqa: E501
        if 'recipient_integration_id' in local_var_params and local_var_params['recipient_integration_id'] is not None:  # noqa: E501
            query_params.append(('recipientIntegrationId', local_var_params['recipient_integration_id']))  # noqa: E501
        if 'batch_id' in local_var_params and local_var_params['batch_id'] is not None:  # noqa: E501
            query_params.append(('batchId', local_var_params['batch_id']))  # noqa: E501
        if 'exact_match' in local_var_params and local_var_params['exact_match'] is not None:  # noqa: E501
            query_params.append(('exactMatch', local_var_params['exact_match']))  # noqa: E501
        if 'campaign_state' in local_var_params and local_var_params['campaign_state'] is not None:  # noqa: E501
            query_params.append(('campaignState', local_var_params['campaign_state']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/coupons_search_advanced', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2001',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_coupons_advanced_application_wide_without_total_count(self, application_id, body, **kwargs):  # noqa: E501
        """Get a list of the coupons that match the given attributes in all active campaigns of an application  # noqa: E501

        Gets a list of all the coupons with attributes matching the query criteria in all active campaigns of an application   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_coupons_advanced_application_wide_without_total_count(application_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param object body: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param str batch_id: Filter results by batches of coupons
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :param str campaign_state: Filter results by the state of the campaign.
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.search_coupons_advanced_application_wide_without_total_count_with_http_info(application_id, body, **kwargs)  # noqa: E501

    def search_coupons_advanced_application_wide_without_total_count_with_http_info(self, application_id, body, **kwargs):  # noqa: E501
        """Get a list of the coupons that match the given attributes in all active campaigns of an application  # noqa: E501

        Gets a list of all the coupons with attributes matching the query criteria in all active campaigns of an application   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_coupons_advanced_application_wide_without_total_count_with_http_info(application_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param object body: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param str batch_id: Filter results by batches of coupons
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :param str campaign_state: Filter results by the state of the campaign.
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse2005, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'body', 'page_size', 'skip', 'sort', 'value', 'created_before', 'created_after', 'valid', 'usable', 'referral_id', 'recipient_integration_id', 'batch_id', 'exact_match', 'campaign_state']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_coupons_advanced_application_wide_without_total_count" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `search_coupons_advanced_application_wide_without_total_count`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `search_coupons_advanced_application_wide_without_total_count`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'value' in local_var_params and local_var_params['value'] is not None:  # noqa: E501
            query_params.append(('value', local_var_params['value']))  # noqa: E501
        if 'created_before' in local_var_params and local_var_params['created_before'] is not None:  # noqa: E501
            query_params.append(('createdBefore', local_var_params['created_before']))  # noqa: E501
        if 'created_after' in local_var_params and local_var_params['created_after'] is not None:  # noqa: E501
            query_params.append(('createdAfter', local_var_params['created_after']))  # noqa: E501
        if 'valid' in local_var_params and local_var_params['valid'] is not None:  # noqa: E501
            query_params.append(('valid', local_var_params['valid']))  # noqa: E501
        if 'usable' in local_var_params and local_var_params['usable'] is not None:  # noqa: E501
            query_params.append(('usable', local_var_params['usable']))  # noqa: E501
        if 'referral_id' in local_var_params and local_var_params['referral_id'] is not None:  # noqa: E501
            query_params.append(('referralId', local_var_params['referral_id']))  # noqa: E501
        if 'recipient_integration_id' in local_var_params and local_var_params['recipient_integration_id'] is not None:  # noqa: E501
            query_params.append(('recipientIntegrationId', local_var_params['recipient_integration_id']))  # noqa: E501
        if 'batch_id' in local_var_params and local_var_params['batch_id'] is not None:  # noqa: E501
            query_params.append(('batchId', local_var_params['batch_id']))  # noqa: E501
        if 'exact_match' in local_var_params and local_var_params['exact_match'] is not None:  # noqa: E501
            query_params.append(('exactMatch', local_var_params['exact_match']))  # noqa: E501
        if 'campaign_state' in local_var_params and local_var_params['campaign_state'] is not None:  # noqa: E501
            query_params.append(('campaignState', local_var_params['campaign_state']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/coupons_search_advanced/no_total', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2005',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_coupons_advanced_without_total_count(self, application_id, campaign_id, body, **kwargs):  # noqa: E501
        """Get a list of the coupons that match the given attributes  # noqa: E501

        Gets a list of all the coupons with attributes matching the query criteria   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_coupons_advanced_without_total_count(application_id, campaign_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param object body: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :param str batch_id: Filter results by batches of coupons
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.search_coupons_advanced_without_total_count_with_http_info(application_id, campaign_id, body, **kwargs)  # noqa: E501

    def search_coupons_advanced_without_total_count_with_http_info(self, application_id, campaign_id, body, **kwargs):  # noqa: E501
        """Get a list of the coupons that match the given attributes  # noqa: E501

        Gets a list of all the coupons with attributes matching the query criteria   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_coupons_advanced_without_total_count_with_http_info(application_id, campaign_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param object body: (required)
        :param int page_size: The number of items to include in this response. When omitted, the maximum value of 1000 will be used.
        :param int skip: Skips the given number of items when paging through large result sets.
        :param str sort: The field by which results should be sorted. Sorting defaults to ascending order, prefix the field name with `-` to sort in descending order.
        :param str value: Filter results performing case-insensitive matching against the coupon code. Both the code and the query are folded to remove all non-alpha-numeric characters.
        :param datetime created_before: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param datetime created_after: Filter results comparing the parameter value, expected to be an RFC3339 timestamp string, to the coupon creation timestamp.
        :param str valid: Either \"expired\", \"validNow\", or \"validFuture\". The first option matches coupons in which the expiry date is set and in the past. The second matches coupons in which start date is null or in the past and expiry date is null or in the future, the third matches coupons in which start date is set and in the future. 
        :param str usable: Either \"true\" or \"false\". If \"true\", only coupons where `usageCounter < usageLimit` will be returned, \"false\" will return only coupons where `usageCounter >= usageLimit`. 
        :param int referral_id: Filter the results by matching them with the Id of a referral, that meaning the coupons that had been created as an effect of the usage of a referral code.
        :param str recipient_integration_id: Filter results by match with a profile id specified in the coupon's RecipientIntegrationId field
        :param bool exact_match: Filter results to an exact case-insensitive matching against the coupon code
        :param str batch_id: Filter results by batches of coupons
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(InlineResponse2005, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'campaign_id', 'body', 'page_size', 'skip', 'sort', 'value', 'created_before', 'created_after', 'valid', 'usable', 'referral_id', 'recipient_integration_id', 'exact_match', 'batch_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_coupons_advanced_without_total_count" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `search_coupons_advanced_without_total_count`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if self.api_client.client_side_validation and ('campaign_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['campaign_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `campaign_id` when calling `search_coupons_advanced_without_total_count`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `search_coupons_advanced_without_total_count`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501
        if 'campaign_id' in local_var_params:
            path_params['campaignId'] = local_var_params['campaign_id']  # noqa: E501

        query_params = []
        if 'page_size' in local_var_params and local_var_params['page_size'] is not None:  # noqa: E501
            query_params.append(('pageSize', local_var_params['page_size']))  # noqa: E501
        if 'skip' in local_var_params and local_var_params['skip'] is not None:  # noqa: E501
            query_params.append(('skip', local_var_params['skip']))  # noqa: E501
        if 'sort' in local_var_params and local_var_params['sort'] is not None:  # noqa: E501
            query_params.append(('sort', local_var_params['sort']))  # noqa: E501
        if 'value' in local_var_params and local_var_params['value'] is not None:  # noqa: E501
            query_params.append(('value', local_var_params['value']))  # noqa: E501
        if 'created_before' in local_var_params and local_var_params['created_before'] is not None:  # noqa: E501
            query_params.append(('createdBefore', local_var_params['created_before']))  # noqa: E501
        if 'created_after' in local_var_params and local_var_params['created_after'] is not None:  # noqa: E501
            query_params.append(('createdAfter', local_var_params['created_after']))  # noqa: E501
        if 'valid' in local_var_params and local_var_params['valid'] is not None:  # noqa: E501
            query_params.append(('valid', local_var_params['valid']))  # noqa: E501
        if 'usable' in local_var_params and local_var_params['usable'] is not None:  # noqa: E501
            query_params.append(('usable', local_var_params['usable']))  # noqa: E501
        if 'referral_id' in local_var_params and local_var_params['referral_id'] is not None:  # noqa: E501
            query_params.append(('referralId', local_var_params['referral_id']))  # noqa: E501
        if 'recipient_integration_id' in local_var_params and local_var_params['recipient_integration_id'] is not None:  # noqa: E501
            query_params.append(('recipientIntegrationId', local_var_params['recipient_integration_id']))  # noqa: E501
        if 'exact_match' in local_var_params and local_var_params['exact_match'] is not None:  # noqa: E501
            query_params.append(('exactMatch', local_var_params['exact_match']))  # noqa: E501
        if 'batch_id' in local_var_params and local_var_params['batch_id'] is not None:  # noqa: E501
            query_params.append(('batchId', local_var_params['batch_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons_search_advanced/no_total', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2005',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_additional_cost(self, additional_cost_id, body, **kwargs):  # noqa: E501
        """Update an additional cost  # noqa: E501

        Updates an existing additional cost. Once created, the only property of an additional cost that can be changed is the title (human readable description). This restriction is in place to prevent accidentally breaking live integrations.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_additional_cost(additional_cost_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int additional_cost_id: (required)
        :param NewAdditionalCost body: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: AccountAdditionalCost
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_additional_cost_with_http_info(additional_cost_id, body, **kwargs)  # noqa: E501

    def update_additional_cost_with_http_info(self, additional_cost_id, body, **kwargs):  # noqa: E501
        """Update an additional cost  # noqa: E501

        Updates an existing additional cost. Once created, the only property of an additional cost that can be changed is the title (human readable description). This restriction is in place to prevent accidentally breaking live integrations.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_additional_cost_with_http_info(additional_cost_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int additional_cost_id: (required)
        :param NewAdditionalCost body: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(AccountAdditionalCost, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['additional_cost_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_additional_cost" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'additional_cost_id' is set
        if self.api_client.client_side_validation and ('additional_cost_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['additional_cost_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `additional_cost_id` when calling `update_additional_cost`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `update_additional_cost`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'additional_cost_id' in local_var_params:
            path_params['additionalCostId'] = local_var_params['additional_cost_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/additional_costs/{additionalCostId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='AccountAdditionalCost',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_attribute(self, attribute_id, body, **kwargs):  # noqa: E501
        """Update a custom attribute  # noqa: E501

        Updates an existing custom attribute. Once created, the only property of a custom attribute that can be changed is the title (human readable description). This restriction is in place to prevent accidentally breaking live integrations. E.g. if you have a customer profile attribute with the name `region`, and your integration is sending `attributes.region` with customer profile updates, changing the name to `locale` would cause the integration requests to begin failing.  If you **really** need to change the `type` or `name` property of a custom attribute, create a new attribute and update any relevant integrations and rules to use the new attribute. Then delete the old attribute when you are confident you have migrated any needed data from the old attribute to the new one.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_attribute(attribute_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int attribute_id: (required)
        :param NewAttribute body: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Attribute
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_attribute_with_http_info(attribute_id, body, **kwargs)  # noqa: E501

    def update_attribute_with_http_info(self, attribute_id, body, **kwargs):  # noqa: E501
        """Update a custom attribute  # noqa: E501

        Updates an existing custom attribute. Once created, the only property of a custom attribute that can be changed is the title (human readable description). This restriction is in place to prevent accidentally breaking live integrations. E.g. if you have a customer profile attribute with the name `region`, and your integration is sending `attributes.region` with customer profile updates, changing the name to `locale` would cause the integration requests to begin failing.  If you **really** need to change the `type` or `name` property of a custom attribute, create a new attribute and update any relevant integrations and rules to use the new attribute. Then delete the old attribute when you are confident you have migrated any needed data from the old attribute to the new one.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_attribute_with_http_info(attribute_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int attribute_id: (required)
        :param NewAttribute body: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Attribute, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['attribute_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_attribute" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'attribute_id' is set
        if self.api_client.client_side_validation and ('attribute_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['attribute_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `attribute_id` when calling `update_attribute`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `update_attribute`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'attribute_id' in local_var_params:
            path_params['attributeId'] = local_var_params['attribute_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/attributes/{attributeId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Attribute',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_campaign(self, application_id, campaign_id, body, **kwargs):  # noqa: E501
        """Update a Campaign  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_campaign(application_id, campaign_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param UpdateCampaign body: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Campaign
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_campaign_with_http_info(application_id, campaign_id, body, **kwargs)  # noqa: E501

    def update_campaign_with_http_info(self, application_id, campaign_id, body, **kwargs):  # noqa: E501
        """Update a Campaign  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_campaign_with_http_info(application_id, campaign_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param UpdateCampaign body: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Campaign, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'campaign_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_campaign" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `update_campaign`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if self.api_client.client_side_validation and ('campaign_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['campaign_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `campaign_id` when calling `update_campaign`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `update_campaign`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501
        if 'campaign_id' in local_var_params:
            path_params['campaignId'] = local_var_params['campaign_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Campaign',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_campaign_set(self, application_id, body, **kwargs):  # noqa: E501
        """Update a Campaign Set  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_campaign_set(application_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param NewCampaignSet body: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: CampaignSet
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_campaign_set_with_http_info(application_id, body, **kwargs)  # noqa: E501

    def update_campaign_set_with_http_info(self, application_id, body, **kwargs):  # noqa: E501
        """Update a Campaign Set  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_campaign_set_with_http_info(application_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param NewCampaignSet body: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(CampaignSet, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_campaign_set" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `update_campaign_set`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `update_campaign_set`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaign_set', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CampaignSet',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_coupon(self, application_id, campaign_id, coupon_id, body, **kwargs):  # noqa: E501
        """Update a Coupon  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_coupon(application_id, campaign_id, coupon_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param str coupon_id: The ID of the coupon code to update (required)
        :param UpdateCoupon body: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Coupon
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_coupon_with_http_info(application_id, campaign_id, coupon_id, body, **kwargs)  # noqa: E501

    def update_coupon_with_http_info(self, application_id, campaign_id, coupon_id, body, **kwargs):  # noqa: E501
        """Update a Coupon  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_coupon_with_http_info(application_id, campaign_id, coupon_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param str coupon_id: The ID of the coupon code to update (required)
        :param UpdateCoupon body: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Coupon, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'campaign_id', 'coupon_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_coupon" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `update_coupon`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if self.api_client.client_side_validation and ('campaign_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['campaign_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `campaign_id` when calling `update_coupon`")  # noqa: E501
        # verify the required parameter 'coupon_id' is set
        if self.api_client.client_side_validation and ('coupon_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['coupon_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `coupon_id` when calling `update_coupon`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `update_coupon`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501
        if 'campaign_id' in local_var_params:
            path_params['campaignId'] = local_var_params['campaign_id']  # noqa: E501
        if 'coupon_id' in local_var_params:
            path_params['couponId'] = local_var_params['coupon_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons/{couponId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Coupon',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_coupon_batch(self, application_id, campaign_id, body, **kwargs):  # noqa: E501
        """Update a Batch of Coupons  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_coupon_batch(application_id, campaign_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param UpdateCouponBatch body: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_coupon_batch_with_http_info(application_id, campaign_id, body, **kwargs)  # noqa: E501

    def update_coupon_batch_with_http_info(self, application_id, campaign_id, body, **kwargs):  # noqa: E501
        """Update a Batch of Coupons  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_coupon_batch_with_http_info(application_id, campaign_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param UpdateCouponBatch body: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'campaign_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_coupon_batch" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `update_coupon_batch`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if self.api_client.client_side_validation and ('campaign_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['campaign_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `campaign_id` when calling `update_coupon_batch`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `update_coupon_batch`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501
        if 'campaign_id' in local_var_params:
            path_params['campaignId'] = local_var_params['campaign_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/coupons', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)

    def update_ruleset(self, application_id, campaign_id, ruleset_id, body, **kwargs):  # noqa: E501
        """Update a Ruleset  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_ruleset(application_id, campaign_id, ruleset_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param int ruleset_id: (required)
        :param NewRuleset body: (required)
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Ruleset
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        return self.update_ruleset_with_http_info(application_id, campaign_id, ruleset_id, body, **kwargs)  # noqa: E501

    def update_ruleset_with_http_info(self, application_id, campaign_id, ruleset_id, body, **kwargs):  # noqa: E501
        """Update a Ruleset  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.update_ruleset_with_http_info(application_id, campaign_id, ruleset_id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool: execute request asynchronously
        :param int application_id: (required)
        :param int campaign_id: (required)
        :param int ruleset_id: (required)
        :param NewRuleset body: (required)
        :param _return_http_data_only: response data without head status code
                                       and headers
        :param _preload_content: if False, the urllib3.HTTPResponse object will
                                 be returned without reading/decoding response
                                 data. Default is True.
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: tuple(Ruleset, status_code(int), headers(HTTPHeaderDict))
                 If the method is called asynchronously,
                 returns the request thread.
        """

        local_var_params = locals()

        all_params = ['application_id', 'campaign_id', 'ruleset_id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        for key, val in six.iteritems(local_var_params['kwargs']):
            if key not in all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_ruleset" % key
                )
            local_var_params[key] = val
        del local_var_params['kwargs']
        # verify the required parameter 'application_id' is set
        if self.api_client.client_side_validation and ('application_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['application_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `application_id` when calling `update_ruleset`")  # noqa: E501
        # verify the required parameter 'campaign_id' is set
        if self.api_client.client_side_validation and ('campaign_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['campaign_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `campaign_id` when calling `update_ruleset`")  # noqa: E501
        # verify the required parameter 'ruleset_id' is set
        if self.api_client.client_side_validation and ('ruleset_id' not in local_var_params or  # noqa: E501
                                                        local_var_params['ruleset_id'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `ruleset_id` when calling `update_ruleset`")  # noqa: E501
        # verify the required parameter 'body' is set
        if self.api_client.client_side_validation and ('body' not in local_var_params or  # noqa: E501
                                                        local_var_params['body'] is None):  # noqa: E501
            raise ApiValueError("Missing the required parameter `body` when calling `update_ruleset`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'application_id' in local_var_params:
            path_params['applicationId'] = local_var_params['application_id']  # noqa: E501
        if 'campaign_id' in local_var_params:
            path_params['campaignId'] = local_var_params['campaign_id']  # noqa: E501
        if 'ruleset_id' in local_var_params:
            path_params['rulesetId'] = local_var_params['ruleset_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in local_var_params:
            body_params = local_var_params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['manager_auth']  # noqa: E501

        return self.api_client.call_api(
            '/v1/applications/{applicationId}/campaigns/{campaignId}/rulesets/{rulesetId}', 'PUT',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Ruleset',  # noqa: E501
            auth_settings=auth_settings,
            async_req=local_var_params.get('async_req'),
            _return_http_data_only=local_var_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=local_var_params.get('_preload_content', True),
            _request_timeout=local_var_params.get('_request_timeout'),
            collection_formats=collection_formats)
